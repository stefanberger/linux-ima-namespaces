From 234408480f381a552dd4d4f10993650b6070bf44 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Sun, 2 Jan 2022 00:10:34 -0500
Subject: [PATCH 36/53] ima: Move ima_appraise into ima_namespace

Move ima_appraise into ima_namespace and initialize it for the host
as before and set it to enforcing for IMA namespaces when
CONFIG_IMA_APPRAISE is set.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/ima.h                      |  4 +--
 security/integrity/ima/ima.h             |  3 ++-
 security/integrity/ima/ima_appraise.c    | 16 +++++-------
 security/integrity/ima/ima_fs.c          |  3 +--
 security/integrity/ima/ima_init_ima_ns.c |  8 ++++++
 security/integrity/ima/ima_main.c        | 33 ++++++++++--------------
 security/integrity/ima/ima_policy.c      |  4 +--
 7 files changed, 36 insertions(+), 35 deletions(-)

diff --git a/include/linux/ima.h b/include/linux/ima.h
index 68f02c5d797c..77aa4b3a8c15 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -182,14 +182,14 @@ static inline void ima_post_key_create_or_update(struct key *keyring,
 #endif  /* CONFIG_IMA_MEASURE_ASYMMETRIC_KEYS */
 
 #ifdef CONFIG_IMA_APPRAISE
-extern bool is_ima_appraise_enabled(void);
+extern bool is_ima_appraise_enabled(struct ima_namespace *ns);
 extern void ima_inode_post_setattr(struct user_namespace *mnt_userns,
 				   struct dentry *dentry);
 extern int ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,
 		       const void *xattr_value, size_t xattr_value_len);
 extern int ima_inode_removexattr(struct dentry *dentry, const char *xattr_name);
 #else
-static inline bool is_ima_appraise_enabled(void)
+static inline bool is_ima_appraise_enabled(struct ima_namespace *ns)
 {
 	return 0;
 }
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 4f7057a61cd5..dcc8218b37c9 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -49,7 +49,6 @@ enum tpm_pcrs { TPM_PCR0 = 0, TPM_PCR8 = 8, TPM_PCR10 = 10 };
 extern atomic_t ima_setxattr_allowed_hash_algorithms;
 
 /* set during initialization */
-extern int ima_appraise;
 extern const char boot_aggregate_name[];
 
 /* IMA event related data */
@@ -202,6 +201,8 @@ struct ima_namespace {
 	struct ima_template_desc *ima_buf_template;
 
 	struct integrity_namespace *integrity_ns;
+
+	int ima_appraise;
 } __randomize_layout;
 extern struct ima_namespace init_ima_ns;
 
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index 3f78aeb6c545..507016f13d5b 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -26,7 +26,8 @@ void __init ima_appraise_parse_cmdline(void)
 {
 	const char *str = ima_appraise_cmdline_default;
 	bool sb_state = arch_ima_get_secureboot();
-	int appraisal_state = ima_appraise;
+	struct ima_namespace *ns = get_current_ns();
+	int appraisal_state = ns->ima_appraise;
 
 	if (!str)
 		return;
@@ -49,7 +50,7 @@ void __init ima_appraise_parse_cmdline(void)
 			pr_info("Secure boot enabled: ignoring ima_appraise=%s option",
 				str);
 	} else {
-		ima_appraise = appraisal_state;
+		ns->ima_appraise = appraisal_state;
 	}
 }
 #endif
@@ -59,9 +60,9 @@ void __init ima_appraise_parse_cmdline(void)
  *
  * Only return enabled, if not in ima_appraise="fix" or "log" modes.
  */
-bool is_ima_appraise_enabled(void)
+bool is_ima_appraise_enabled(struct ima_namespace *ns)
 {
-	return ima_appraise & IMA_APPRAISE_ENFORCE;
+	return ns->ima_appraise & IMA_APPRAISE_ENFORCE;
 }
 
 /*
@@ -75,10 +76,7 @@ int ima_must_appraise(struct ima_namespace *ns,
 {
 	u32 secid;
 
-	if (ns != &init_ima_ns)
-		return 0;
-
-	if (!ima_appraise)
+	if (!ns->ima_appraise)
 		return 0;
 
 	security_current_getsecid_subj(&secid);
@@ -484,7 +482,7 @@ int ima_appraise_measurement(struct ima_namespace *ns,
 				    op, cause, rc, 0);
 	} else if (status != INTEGRITY_PASS) {
 		/* Fix mode, but don't replace file signatures. */
-		if ((ima_appraise & IMA_APPRAISE_FIX) && !try_modsig &&
+		if ((ns->ima_appraise & IMA_APPRAISE_FIX) && !try_modsig &&
 		    (!xattr_value ||
 		     xattr_value->type != EVM_IMA_XATTR_DIGSIG)) {
 			if (!ima_fix_xattr(dentry, ns_status))
diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index 99e35b3f41e5..e81e3c048e13 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -364,8 +364,7 @@ static ssize_t ima_write_policy(struct file *file, const char __user *buf,
 
 	if (data[0] == '/') {
 		result = ima_read_policy(user_ns, data);
-	} else if (ns == &init_ima_ns &&
-		   (ima_appraise & IMA_APPRAISE_POLICY)) {
+	} else if (ns->ima_appraise & IMA_APPRAISE_POLICY) {
 		pr_err("signed policy file (specified as an absolute pathname) required\n");
 		integrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,
 				    "policy_update", "signed policy required",
diff --git a/security/integrity/ima/ima_init_ima_ns.c b/security/integrity/ima/ima_init_ima_ns.c
index b6cf32dd1788..5d7e4efb6f91 100644
--- a/security/integrity/ima/ima_init_ima_ns.c
+++ b/security/integrity/ima/ima_init_ima_ns.c
@@ -45,6 +45,10 @@ int ima_init_namespace(struct ima_namespace *ns)
 	else
 		ns->ima_process_keys = true;
 
+#ifdef CONFIG_IMA_APPRAISE
+	ns->ima_appraise = IMA_APPRAISE_ENFORCE;
+#endif
+
 	if (ns != &init_ima_ns) {
 		ns->ima_lsm_policy_notifier.notifier_call =
 						ima_lsm_policy_change;
@@ -53,6 +57,7 @@ int ima_init_namespace(struct ima_namespace *ns)
 		if (ret)
 			return ret;
 	}
+
 	if (ns == &init_ima_ns) {
 		ns->ima_tpm_chip = tpm_default_chip();
 		if (ns->ima_tpm_chip)
@@ -114,5 +119,8 @@ struct ima_namespace init_ima_ns = {
 		.template_name = CONFIG_IMA_DEFAULT_TEMPLATE,
 	},
 	.integrity_ns = &init_integrity_ns,
+#ifdef CONFIG_IMA_APPRAISE
+	.ima_appraise = IMA_APPRAISE_ENFORCE,
+#endif
 };
 EXPORT_SYMBOL(init_ima_ns);
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index dbb8820d7316..6db59114c98d 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -29,12 +29,6 @@
 
 #include "ima.h"
 
-#ifdef CONFIG_IMA_APPRAISE
-int ima_appraise = IMA_APPRAISE_ENFORCE;
-#else
-int ima_appraise;
-#endif
-
 static int __init hash_setup(struct ima_config *ic, char *str)
 {
 	struct ima_namespace *ns = &init_ima_ns;
@@ -437,7 +431,7 @@ static int __process_measurement(struct ima_namespace *ns,
 	if (pathbuf)
 		__putname(pathbuf);
 	if (must_appraise) {
-		if (rc && (ima_appraise & IMA_APPRAISE_ENFORCE))
+		if (rc && (ns->ima_appraise & IMA_APPRAISE_ENFORCE))
 			return -EACCES;
 		if (file->f_mode & FMODE_WRITE)
 			set_bit(IMA_UPDATE_XATTR, &iint->atomic_flags);
@@ -855,8 +849,8 @@ int ima_post_read_file(struct file *file, void *buf, loff_t size,
 		return 0;
 
 	if (!file || !buf || size == 0) { /* should never happen */
-		if (ns == &init_ima_ns &&
-		    (ima_appraise & IMA_APPRAISE_ENFORCE))
+		if (ns_is_active(ns) &&
+		    ns->ima_appraise & IMA_APPRAISE_ENFORCE)
 			return -EACCES;
 		return 0;
 	}
@@ -884,11 +878,8 @@ int ima_load_data(enum kernel_load_data_id id, bool contents)
 	struct ima_namespace *ns = get_current_ns();
 	bool ima_enforce, sig_enforce;
 
-	if (ns != &init_ima_ns)
-		return 0;
-
 	ima_enforce =
-		(ima_appraise & IMA_APPRAISE_ENFORCE) == IMA_APPRAISE_ENFORCE;
+	    (ns->ima_appraise & IMA_APPRAISE_ENFORCE) == IMA_APPRAISE_ENFORCE;
 
 	switch (id) {
 	case LOADING_KEXEC_IMAGE:
@@ -898,13 +889,14 @@ int ima_load_data(enum kernel_load_data_id id, bool contents)
 			return -EACCES;
 		}
 
-		if (ima_enforce && (ima_appraise & IMA_APPRAISE_KEXEC)) {
+		if (ima_enforce && (ns->ima_appraise & IMA_APPRAISE_KEXEC)) {
 			pr_err("impossible to appraise a kernel image without a file descriptor; try using kexec_file_load syscall.\n");
 			return -EACCES;	/* INTEGRITY_UNKNOWN */
 		}
 		break;
 	case LOADING_FIRMWARE:
-		if (ima_enforce && (ima_appraise & IMA_APPRAISE_FIRMWARE) && !contents) {
+		if (ima_enforce &&
+		    (ns->ima_appraise & IMA_APPRAISE_FIRMWARE) && !contents) {
 			pr_err("Prevent firmware sysfs fallback loading.\n");
 			return -EACCES;	/* INTEGRITY_UNKNOWN */
 		}
@@ -912,8 +904,9 @@ int ima_load_data(enum kernel_load_data_id id, bool contents)
 	case LOADING_MODULE:
 		sig_enforce = is_module_sig_enforced();
 
-		if (ima_enforce && (!sig_enforce
-				    && (ima_appraise & IMA_APPRAISE_MODULES))) {
+		if (ima_enforce &&
+		    (!sig_enforce &&
+		     (ns->ima_appraise & IMA_APPRAISE_MODULES))) {
 			pr_err("impossible to appraise a module without a file descriptor. sig_enforce kernel parameter might help\n");
 			return -EACCES;	/* INTEGRITY_UNKNOWN */
 		}
@@ -941,9 +934,11 @@ int ima_post_load_data(char *buf, loff_t size,
 		       enum kernel_load_data_id load_id,
 		       char *description)
 {
+	struct ima_namespace *ns = get_current_ns();
+
 	if (load_id == LOADING_FIRMWARE) {
-		if ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&
-		    (ima_appraise & IMA_APPRAISE_ENFORCE)) {
+		if ((ns->ima_appraise & IMA_APPRAISE_FIRMWARE) &&
+		    (ns->ima_appraise & IMA_APPRAISE_ENFORCE)) {
 			pr_err("Prevent firmware loading_store.\n");
 			return -EACCES; /* INTEGRITY_UNKNOWN */
 		}
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index 25b247d248a9..4d4e70d0b19a 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -810,8 +810,8 @@ void ima_update_policy_flags(struct ima_namespace *ns)
 	}
 	rcu_read_unlock();
 
-	ima_appraise |= (build_ima_appraise | temp_ima_appraise);
-	if (!ima_appraise)
+	ns->ima_appraise |= (build_ima_appraise | temp_ima_appraise);
+	if (!ns->ima_appraise)
 		new_policy_flag &= ~IMA_APPRAISE;
 
 	ns->ima_policy_flag = new_policy_flag;
-- 
2.31.1

