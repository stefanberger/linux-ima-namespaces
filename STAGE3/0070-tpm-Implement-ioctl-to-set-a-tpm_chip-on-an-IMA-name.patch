From 66de32f41eebed1be0b44408a5d0a6d3e9a1829d Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Sat, 29 Jul 2017 16:25:21 -0400
Subject: [PATCH 70/80] tpm: Implement ioctl to set a tpm_chip on an IMA
 namespace

Implement an ioctl for the vtpm proxy 'server side'. The ioctl is
available for the anonymous file descriptor returned from the operation
on /dev/vtpmx. It enables the setting of a tpm_chip on an ima_namespace.
The operation may be rejected if a tpm_chip is already in use by an IMA
namespace or the IMA namespace already has a tpm_chip or if IMA
namespacing is not supported.

The tpm_chip is later on released when the IMA namespace is torn down.
The teardown may take a while since user namespace teardown is only
occurring much later than for example the termination of a user namespace.
Therefore, seemingly stale TPM devices (/dev/tpmX and /dev/tpmrmX) may be
kept around for a while until the user namespace is freed.

Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
---
 drivers/char/tpm/tpm_vtpm_proxy.c | 108 +++++++++++++++++++++++++++++-
 include/uapi/linux/vtpm_proxy.h   |   6 ++
 2 files changed, 113 insertions(+), 1 deletion(-)

diff --git a/drivers/char/tpm/tpm_vtpm_proxy.c b/drivers/char/tpm/tpm_vtpm_proxy.c
index e2a2274ace7b..e0d9cfb254f0 100644
--- a/drivers/char/tpm/tpm_vtpm_proxy.c
+++ b/drivers/char/tpm/tpm_vtpm_proxy.c
@@ -20,6 +20,7 @@
 #include <linux/anon_inodes.h>
 #include <linux/poll.h>
 #include <linux/compat.h>
+#include <linux/ima.h>
 
 #include "tpm.h"
 
@@ -33,13 +34,14 @@ struct proxy_dev {
 
 	wait_queue_head_t wq;
 
-	struct mutex buf_lock;       /* protect buffer and flags */
+	struct mutex buf_lock;       /* protect buffer, flags, and state */
 
 	long state;                  /* internal state */
 #define STATE_OPENED_FLAG        BIT(0)
 #define STATE_WAIT_RESPONSE_FLAG BIT(1)  /* waiting for emulator response */
 #define STATE_REGISTERED_FLAG	 BIT(2)
 #define STATE_DRIVER_COMMAND     BIT(3)  /* sending a driver specific command */
+#define STATE_USED_BY_IMA_NS     BIT(4)  /* used by an IMA namespace */
 
 	size_t req_len;              /* length of queued TPM request */
 	size_t resp_len;             /* length of queued TPM response */
@@ -54,11 +56,102 @@ struct proxy_dev {
 static struct workqueue_struct *workqueue;
 
 static void vtpm_proxy_delete_device(struct proxy_dev *proxy_dev);
+static void vtpm_proxy_fops_undo_open(struct proxy_dev *proxy_dev);
+static struct tpm_provider vtpm_tpm_provider;
+static inline void vtpm_proxy_get_proxy_dev(struct proxy_dev *proxy_dev);
+static inline void vtpm_proxy_put_proxy_dev(struct proxy_dev *proxy_dev);
 
 /*
  * Functions related to 'server side'
  */
 
+/**
+ * vtpm_proxy_set_chip_imans - connect tpm_chip to currently active IMA-ns
+ *
+ * @proxy_dev: tpm proxy device
+ * @filp: file pointer
+ */
+static int vtpm_proxy_set_chip_imans(struct proxy_dev *proxy_dev,
+				     struct file *filp)
+{
+	int rc;
+
+	/* initialization must have completed */
+	flush_work(&proxy_dev->work);
+
+	mutex_lock(&proxy_dev->buf_lock);
+
+	if (!(proxy_dev->state & STATE_OPENED_FLAG)) {
+		rc = -EINVAL;
+		goto err_unlock;
+	}
+
+	if (proxy_dev->state & STATE_USED_BY_IMA_NS) {
+		rc = -EBUSY;
+		goto err_unlock;
+	}
+
+	rc = ima_ns_set_tpm_chip(&vtpm_tpm_provider, proxy_dev->chip);
+	if (!rc) {
+		proxy_dev->state |= STATE_USED_BY_IMA_NS;
+		vtpm_proxy_get_proxy_dev(proxy_dev);
+	}
+
+err_unlock:
+	mutex_unlock(&proxy_dev->buf_lock);
+
+	return rc;
+}
+
+/**
+ * vtpm_proxy_release_chip - kernel subsystem (IMA) releases chip
+ *
+ * @tpm_chip: tpm_chip to release
+ */
+void vtpm_proxy_release_chip(struct tpm_chip *chip)
+{
+	struct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);
+
+	/* notify 'server side' application with a HUP */
+	vtpm_proxy_fops_undo_open(proxy_dev);
+
+	/*
+	 * release reference we're holding since vtpm_set_chip_imans
+	 */
+	mutex_lock(&proxy_dev->buf_lock);
+	proxy_dev->state &= ~STATE_USED_BY_IMA_NS;
+	mutex_unlock(&proxy_dev->buf_lock);
+
+	vtpm_proxy_put_proxy_dev(proxy_dev);
+}
+
+static long vtpm_proxy_ioctl_connect_to_ima_ns(struct file *filp)
+{
+	struct proxy_dev *proxy_dev = filp->private_data;
+
+	WARN_ON(!proxy_dev);
+
+	return vtpm_proxy_set_chip_imans(proxy_dev, filp);
+}
+
+/**
+ * vtpm_proxy_fops_ioctl - ioctl command on 'server side'
+ *
+ * @filp: file pointer
+ * @ioctl: ioctl number
+ * @arg: argument
+ */
+static long vtpm_proxy_fops_ioctl(struct file *filp, unsigned int ioctl,
+				  unsigned long arg)
+{
+	switch (ioctl) {
+	case VTPM_PROXY_IOC_CONNECT_TO_IMA_NS:
+		return vtpm_proxy_ioctl_connect_to_ima_ns(filp);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
 /**
  * vtpm_proxy_fops_read - Read TPM commands on 'server side'
  *
@@ -249,6 +342,7 @@ static const struct file_operations vtpm_proxy_fops = {
 	.write = vtpm_proxy_fops_write,
 	.poll = vtpm_proxy_fops_poll,
 	.release = vtpm_proxy_fops_release,
+	.unlocked_ioctl = vtpm_proxy_fops_ioctl,
 };
 
 /*
@@ -538,6 +632,14 @@ static inline void vtpm_proxy_put_proxy_dev(struct proxy_dev *proxy_dev)
 	kref_put(&proxy_dev->kref, vtpm_proxy_delete_proxy_dev);
 }
 
+/*
+ * Get a reference to proxy_dev
+ */
+static inline void vtpm_proxy_get_proxy_dev(struct proxy_dev *proxy_dev)
+{
+	kref_get(&proxy_dev->kref);
+}
+
 /*
  * Create a /dev/tpm%d and 'server side' file descriptor pair
  *
@@ -707,6 +809,10 @@ static void vtpmx_cleanup(void)
 	misc_deregister(&vtpmx_miscdev);
 }
 
+static struct tpm_provider vtpm_tpm_provider = {
+	.release_chip = vtpm_proxy_release_chip,
+};
+
 static int __init vtpm_module_init(void)
 {
 	int rc;
diff --git a/include/uapi/linux/vtpm_proxy.h b/include/uapi/linux/vtpm_proxy.h
index 31a30f33ac46..6f91f9dfd670 100644
--- a/include/uapi/linux/vtpm_proxy.h
+++ b/include/uapi/linux/vtpm_proxy.h
@@ -51,4 +51,10 @@ struct vtpm_proxy_new_dev {
 #define TPM2_CC_SET_LOCALITY	0x20001000
 #define TPM_ORD_SET_LOCALITY	0x20001000
 
+/*
+ * ioctl for the file descriptor 'fd' returned by VTPM_PROXY_IOC_NEW_DEV ioctl.
+ * Use it to connect a tpm_chip to an IMA namespace.
+ */
+#define VTPM_PROXY_IOC_CONNECT_TO_IMA_NS  _IO(0xa1, 0x10)
+
 #endif /* _UAPI_LINUX_VTPM_PROXY_H */
-- 
2.36.1

