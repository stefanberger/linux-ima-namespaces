From 50a6387ad607b5d134074a155b1c1a00ce8c0aad Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Mon, 3 Jan 2022 21:05:55 -0500
Subject: [PATCH 32/51] integrity: Move integrity_dir into integrity_namespace

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/integrity_namespace.h |  1 +
 security/integrity/evm/evm.h        |  2 +-
 security/integrity/evm/evm_main.c   |  2 +-
 security/integrity/evm/evm_secfs.c  |  5 +++--
 security/integrity/iint.c           | 25 +++++++++++++++++--------
 security/integrity/ima/ima.h        |  5 +++--
 security/integrity/ima/ima_fs.c     | 22 +++++-----------------
 security/integrity/ima/ima_ns.c     | 13 ++++++++++++-
 security/integrity/integrity.h      |  5 +++--
 security/integrity/integrity_ns.c   |  3 +++
 10 files changed, 49 insertions(+), 34 deletions(-)

diff --git a/include/linux/integrity_namespace.h b/include/linux/integrity_namespace.h
index cef06d6a8870..d550084b3bc2 100644
--- a/include/linux/integrity_namespace.h
+++ b/include/linux/integrity_namespace.h
@@ -21,6 +21,7 @@ struct integrity_namespace {
 	struct ima_namespace *ima_ns;
 	struct key *keyring[INTEGRITY_KEYRING_MAX];
 	const char *keyring_name[INTEGRITY_KEYRING_MAX];
+	struct dentry *integrity_dir;
 };
 extern struct integrity_namespace init_integrity_ns;
 
diff --git a/security/integrity/evm/evm.h b/security/integrity/evm/evm.h
index 0d44f41d16f8..10d5ac575682 100644
--- a/security/integrity/evm/evm.h
+++ b/security/integrity/evm/evm.h
@@ -63,6 +63,6 @@ int evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,
 		  struct evm_digest *data);
 int evm_init_hmac(struct inode *inode, const struct xattr *xattr,
 		  char *hmac_val);
-int evm_init_secfs(void);
+int evm_init_secfs(struct integrity_namespace *ns);
 
 #endif
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index b44de54b9935..d42d69402ffb 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -901,7 +901,7 @@ static int __init init_evm(void)
 	if (error)
 		goto error;
 
-	error = evm_init_secfs();
+	error = evm_init_secfs(&init_integrity_ns);
 	if (error < 0) {
 		pr_info("Error registering secfs\n");
 		goto error;
diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 8a9db7dfca7e..cb879067eba1 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -14,6 +14,7 @@
 #include <linux/uaccess.h>
 #include <linux/init.h>
 #include <linux/mutex.h>
+#include <linux/integrity_namespace.h>
 #include "evm.h"
 
 static struct dentry *evm_dir;
@@ -298,11 +299,11 @@ static int evm_init_xattrs(void)
 }
 #endif
 
-int __init evm_init_secfs(void)
+int __init evm_init_secfs(struct integrity_namespace *ns)
 {
 	int error = 0;
 
-	evm_dir = securityfs_create_dir("evm", integrity_dir);
+	evm_dir = securityfs_create_dir("evm", ns->integrity_dir);
 	if (!evm_dir || IS_ERR(evm_dir))
 		return -EFAULT;
 
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index ea8789dc22b2..1004541701e1 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -27,8 +27,6 @@ static struct rb_root integrity_iint_tree = RB_ROOT;
 static DEFINE_RWLOCK(integrity_iint_lock);
 static struct kmem_cache *iint_cache __read_mostly;
 
-struct dentry *integrity_dir;
-
 /*
  * __integrity_iint_find - return the iint associated with an inode
  */
@@ -237,20 +235,31 @@ void __init integrity_load_keys(void)
 		evm_load_x509(ns);
 }
 
-static int __init integrity_fs_init(void)
+void integrity_fs_free(struct integrity_namespace *ns)
+{
+	/* nothing to do */
+}
+
+int integrity_fs_init(struct integrity_namespace *ns,
+		      struct dentry *secfs_root)
 {
-	integrity_dir = securityfs_create_dir("integrity", NULL);
-	if (IS_ERR(integrity_dir)) {
-		int ret = PTR_ERR(integrity_dir);
+	ns->integrity_dir = securityfs_create_dir("integrity", secfs_root);
+	if (IS_ERR(ns->integrity_dir)) {
+		int ret = PTR_ERR(ns->integrity_dir);
 
 		if (ret != -ENODEV)
 			pr_err("Unable to create integrity sysfs dir: %d\n",
 			       ret);
-		integrity_dir = NULL;
+		ns->integrity_dir = NULL;
 		return ret;
 	}
 
 	return 0;
 }
 
-late_initcall(integrity_fs_init)
+static int __init init_integrity_ns_fs_init(void)
+{
+	return integrity_fs_init(&init_integrity_ns, NULL);
+}
+
+late_initcall(init_integrity_ns_fs_init)
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 1ea7a22ab772..a52012ffd622 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -628,7 +628,8 @@ static inline struct ima_namespace *get_current_ns(void)
 	return ima_ns_from_user_ns(current_user_ns());
 }
 
-struct ima_namespace *create_ima_ns(struct user_namespace *user_ns);
+struct ima_namespace *create_ima_ns(struct user_namespace *user_ns,
+				    struct dentry *secfs_root);
 
 void ima_free_ima_ns(struct ima_namespace *ns);
 
@@ -664,7 +665,7 @@ static inline struct ima_namespace *get_current_ns(void)
 }
 
 static inline struct ima_namespace *
-create_ima_ns(struct user_namespace *user_ns)
+create_ima_ns(struct user_namespace *user_ns, struct dentry *secfs_root)
 {
 	WARN(1, "Cannot create an IMA namespace\n");
 	return ERR_PTR(-EFAULT);
diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index 526297a102a8..bcadbd1cf9df 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -22,6 +22,7 @@
 #include <linux/parser.h>
 #include <linux/vmalloc.h>
 #include <linux/ima.h>
+#include <linux/integrity_namespace.h>
 
 #include "ima.h"
 
@@ -666,27 +667,16 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 	 * user_ns->ima_ns can't change while we're in here.
 	 */
 	if (!ns) {
-		ns = create_ima_ns(user_ns);
+		ns = create_ima_ns(user_ns, root);
 		if (IS_ERR(ns))
 			return PTR_ERR(ns);
 	}
 
-	/* FIXME: update when evm and integrity are namespaced */
-	if (user_ns != &init_user_ns) {
-		int_dir = securityfs_create_dir("integrity", root);
-		if (IS_ERR(int_dir)) {
-			ret = PTR_ERR(int_dir);
-			goto free_ns;
-		}
-	} else {
-		int_dir = integrity_dir;
-	}
+	int_dir = ns->integrity_ns->integrity_dir;
 
 	ima_dir = securityfs_create_dir("ima", int_dir);
-	if (IS_ERR(ima_dir)) {
-		ret = PTR_ERR(ima_dir);
-		goto out;
-	}
+	if (IS_ERR(ima_dir))
+		goto free_ns;
 
 	ima_symlink = securityfs_create_symlink("ima", root, "integrity/ima",
 						NULL);
@@ -778,8 +768,6 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 	securityfs_remove(binary_runtime_measurements);
 	securityfs_remove(ima_symlink);
 	securityfs_remove(ima_dir);
-	if (user_ns != &init_user_ns)
-		securityfs_remove(int_dir);
 
 free_ns:
 	if (!ima_ns_from_user_ns(user_ns))
diff --git a/security/integrity/ima/ima_ns.c b/security/integrity/ima/ima_ns.c
index d9175fc138eb..3de974e25811 100644
--- a/security/integrity/ima/ima_ns.c
+++ b/security/integrity/ima/ima_ns.c
@@ -25,21 +25,32 @@ static struct ima_config *get_parent_config(struct user_namespace *user_ns)
 	return NULL;
 }
 
-struct ima_namespace *create_ima_ns(struct user_namespace *user_ns)
+struct ima_namespace *create_ima_ns(struct user_namespace *user_ns,
+				    struct dentry *secfs_root)
 {
 	struct ima_config *ic = get_parent_config(user_ns);
 	struct ima_namespace *ns;
+	int err;
 
 	ns = kmem_cache_zalloc(imans_cachep, GFP_KERNEL);
 	if (!ns)
 		return ERR_PTR(-ENOMEM);
 
+	err = integrity_fs_init(user_ns->integrity_ns, secfs_root);
+	if (err)
+		goto fail_free;
+
 	/* inherit config from parent */
 	ns->config = *ic;
 
 	ns->integrity_ns = user_ns->integrity_ns;
 
 	return ns;
+
+fail_free:
+	kmem_cache_free(imans_cachep, ns);
+
+	return ERR_PTR(err);
 }
 
 /* destroy_ima_ns() must only be called after ima_init_namespace() was called */
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index 8294fbc90ab1..e6f00ceeb8e3 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -186,11 +186,12 @@ struct integrity_iint_cache *integrity_iint_find(struct inode *inode);
 int integrity_kernel_read(struct file *file, loff_t offset,
 			  void *addr, unsigned long count);
 
-extern struct dentry *integrity_dir;
-
 struct modsig;
 struct integrity_namespace;
 
+int integrity_fs_init(struct integrity_namespace *ns, struct dentry *root);
+void integrity_fs_free(struct integrity_namespace *ns);
+
 #ifdef CONFIG_INTEGRITY_SIGNATURE
 
 int integrity_digsig_verify(struct integrity_namespace *ns,
diff --git a/security/integrity/integrity_ns.c b/security/integrity/integrity_ns.c
index 07a742e2a9d3..176801f83de6 100644
--- a/security/integrity/integrity_ns.c
+++ b/security/integrity/integrity_ns.c
@@ -10,6 +10,8 @@
 #include <linux/ima.h>
 #include <linux/integrity_namespace.h>
 
+#include "integrity.h"
+
 struct integrity_namespace init_integrity_ns = {
 	.ima_ns = &init_ima_ns,
 	.keyring = {NULL, },
@@ -51,6 +53,7 @@ void free_integrity_ns(struct user_namespace *user_ns)
 	size_t i;
 
 	free_ima_ns(user_ns);
+	integrity_fs_free(ns);
 
 	for (i = 0; i < ARRAY_SIZE(ns->keyring); i++)
 		key_put(ns->keyring[i]);
-- 
2.31.1

