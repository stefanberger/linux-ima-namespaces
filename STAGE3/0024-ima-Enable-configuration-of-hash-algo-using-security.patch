From 845a92377fffdce23d0f1d6dacb7cde0a1a990b0 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Tue, 25 Jan 2022 09:13:08 -0500
Subject: [PATCH 24/63] ima: Enable configuration of hash algo using securityfs
 'hash' file

Enable the configuration of the hash algo IMA will be using a new
'hash' file where a user may write the name of the hash into in the IMA
namespace configuration step. Once the IMA namespace is active, the
file can be read and shows the hash algorithm that is used.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 security/integrity/ima/ima_fs.c | 56 +++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index b7c45d02c721..fc56240f90d4 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -480,6 +480,52 @@ static const struct file_operations ima_measure_policy_ops = {
 	.llseek = generic_file_llseek,
 };
 
+static ssize_t ima_show_hash_algo(struct file *filp,
+				  char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	struct ima_namespace *ns = ima_ns_from_file(filp);
+	const char *hash = hash_algo_name[ns->config.ima_hash_algo];
+	ssize_t len = strlen(hash);
+
+	return simple_read_from_buffer(buf, count, ppos, hash, len);
+}
+
+static ssize_t ima_write_hash_algo(struct file *filp,
+				   const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ima_namespace *ns = ima_ns_from_file(filp);
+	char tmpbuf[32];
+	ssize_t ret;
+	char *p;
+	int i;
+
+	if (ns_is_active(ns))
+		return -EBUSY;
+
+	ret = simple_write_to_buffer(tmpbuf, sizeof(tmpbuf) - 1, ppos,
+				     buf, count);
+	if (ret < 0)
+		return ret;
+	tmpbuf[ret] = 0;
+	p = strchr(tmpbuf, '\n');
+	if (p)
+		*p = '\0';
+
+	i = match_string(hash_algo_name, HASH_ALGO__LAST, tmpbuf);
+	if (i < 0)
+		return i;
+	ns->config.ima_hash_algo = i;
+
+	return count;
+}
+
+static const struct file_operations ima_hash_algo_ops = {
+	.read = ima_show_hash_algo,
+	.write = ima_write_hash_algo,
+};
+
 static ssize_t ima_show_active(struct file *filp,
 			       char __user *buf,
 			       size_t count, loff_t *ppos)
@@ -544,6 +590,7 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 	struct dentry *runtime_measurements_count = NULL;
 	struct dentry *violations = NULL;
 	struct dentry *active = NULL;
+	struct dentry *hash_algo = NULL;
 	int ret;
 
 	/*
@@ -631,6 +678,14 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 		}
 	}
 
+	hash_algo =
+	    securityfs_create_file("hash", S_IRUSR | S_IWUSR | S_IRGRP,
+				   ima_dir, NULL, &ima_hash_algo_ops);
+	if (IS_ERR(hash_algo)) {
+		ret = PTR_ERR(hash_algo);
+		goto out;
+	}
+
 	if (ns != &init_ima_ns) {
 		active =
 		    securityfs_create_file("active",
@@ -649,6 +704,7 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 out:
 	securityfs_remove(active);
 	securityfs_remove(ns->ima_policy);
+	securityfs_remove(hash_algo);
 	securityfs_remove(violations);
 	securityfs_remove(runtime_measurements_count);
 	securityfs_remove(ascii_runtime_measurements);
-- 
2.35.1

