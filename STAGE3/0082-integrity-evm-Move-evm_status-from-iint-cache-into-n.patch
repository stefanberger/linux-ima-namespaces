From 365425d27befc78ff2bcd4369e7c040250f36b68 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Fri, 20 May 2022 15:53:15 -0400
Subject: [PATCH 82/89] integrity/evm: Move evm_status from iint cache into
 ns_status

To be able to track the evm_status on a per namespace basis move the
evm_status variable from the integrity_iint_cache into the ns_status
structure.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/evm.h                   |  7 ++--
 include/linux/ima.h                   |  3 ++
 security/integrity/evm/evm_main.c     | 47 ++++++++++++++++++---------
 security/integrity/iint.c             |  2 --
 security/integrity/ima/ima.h          | 17 ----------
 security/integrity/ima/ima_appraise.c |  2 +-
 security/integrity/integrity.h        | 26 ++++++++++++++-
 7 files changed, 66 insertions(+), 38 deletions(-)

diff --git a/include/linux/evm.h b/include/linux/evm.h
index 885a667515a0..de54611abba4 100644
--- a/include/linux/evm.h
+++ b/include/linux/evm.h
@@ -17,6 +17,7 @@
 
 struct integrity_iint_cache;
 struct integrity_namespace;
+struct ns_status;
 
 struct evm_namespace {
 	unsigned long evm_ns_flags;
@@ -66,7 +67,8 @@ extern enum integrity_status evm_verifyxattr(struct evm_namespace *ns,
 					     const char *xattr_name,
 					     void *xattr_value,
 					     size_t xattr_value_len,
-					     struct integrity_iint_cache *iint);
+					     struct integrity_iint_cache *iint,
+					     struct ns_status *ns_status);
 extern int evm_inode_setattr(struct mnt_idmap *idmap,
 			     struct dentry *dentry, struct iattr *attr);
 extern void evm_inode_post_setattr(struct dentry *dentry, int ia_valid);
@@ -136,7 +138,8 @@ static inline enum integrity_status evm_verifyxattr(
 					const char *xattr_name,
 					void *xattr_value,
 					size_t xattr_value_len,
-					struct integrity_iint_cache *iint)
+					struct integrity_iint_cache *iint,
+					struct ns_status *ns_status)
 {
 	return INTEGRITY_UNKNOWN;
 }
diff --git a/include/linux/ima.h b/include/linux/ima.h
index 7aa9788a5a41..7b21e6952f71 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -276,6 +276,9 @@ static inline int ima_securityfs_init(struct user_namespace *user_ns,
 int ima_ns_set_tpm_chip(struct tpm_provider *tpm_provider,
 			struct tpm_chip *chip);
 
+struct ns_status *ima_ns_status_find(struct ima_namespace *ns,
+				     struct inode *inode);
+
 #else
 
 static inline void free_ima_ns(struct user_namespace *user_ns)
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index 8b6aede2f649..dafed138d654 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -21,6 +21,7 @@
 #include <linux/evm.h>
 #include <linux/magic.h>
 #include <linux/posix_acl_xattr.h>
+#include <linux/ima.h>
 
 #include <crypto/hash.h>
 #include <crypto/hash_info.h>
@@ -217,7 +218,8 @@ static enum integrity_status evm_verify_hmac(struct evm_namespace *ns,
 					     const char *xattr_name,
 					     char *xattr_value,
 					     size_t xattr_value_len,
-					     struct integrity_iint_cache *iint)
+					     struct integrity_iint_cache *iint,
+					     struct ns_status *ns_status)
 {
 	struct evm_ima_xattr_data *xattr_data = NULL;
 	struct signature_v2_hdr *hdr;
@@ -226,9 +228,9 @@ static enum integrity_status evm_verify_hmac(struct evm_namespace *ns,
 	struct inode *inode;
 	int rc, xattr_len, evm_immutable = 0;
 
-	if (iint && (iint->evm_status == INTEGRITY_PASS ||
-		     iint->evm_status == INTEGRITY_PASS_IMMUTABLE))
-		return iint->evm_status;
+	if (ns_status && (ns_status->evm_status == INTEGRITY_PASS ||
+			  ns_status->evm_status == INTEGRITY_PASS_IMMUTABLE))
+		return ns_status->evm_status;
 
 	/* if status is not PASS, try to check again - against -ENOMEM */
 
@@ -322,8 +324,8 @@ static enum integrity_status evm_verify_hmac(struct evm_namespace *ns,
 	pr_debug("digest: (%d) [%*phN]\n", digest.hdr.length, digest.hdr.length,
 		  digest.digest);
 out:
-	if (iint)
-		iint->evm_status = evm_status;
+	if (ns_status)
+		ns_status->evm_status = evm_status;
 	kfree(xattr_data);
 	return evm_status;
 }
@@ -464,7 +466,8 @@ enum integrity_status evm_verifyxattr(struct evm_namespace *ns,
 				      struct dentry *dentry,
 				      const char *xattr_name,
 				      void *xattr_value, size_t xattr_value_len,
-				      struct integrity_iint_cache *iint)
+				      struct integrity_iint_cache *iint,
+				      struct ns_status *ns_status)
 {
 	if (!evm_key_loaded(ns) || !evm_protected_xattr(ns, xattr_name))
 		return INTEGRITY_UNKNOWN;
@@ -475,7 +478,7 @@ enum integrity_status evm_verifyxattr(struct evm_namespace *ns,
 			return INTEGRITY_UNKNOWN;
 	}
 	return evm_verify_hmac(ns, dentry, xattr_name, xattr_value,
-				 xattr_value_len, iint);
+				 xattr_value_len, iint, ns_status);
 }
 EXPORT_SYMBOL_GPL(evm_verifyxattr);
 
@@ -493,7 +496,7 @@ static enum integrity_status evm_verify_current_integrity
 
 	if (!evm_key_loaded(ns) || !S_ISREG(inode->i_mode) || evm_fixmode)
 		return INTEGRITY_PASS;
-	return evm_verify_hmac(ns, dentry, NULL, NULL, 0, NULL);
+	return evm_verify_hmac(ns, dentry, NULL, NULL, 0, NULL, NULL);
 }
 
 /*
@@ -760,13 +763,27 @@ int evm_inode_set_acl(struct mnt_idmap *idmap, struct dentry *dentry,
 	return -EPERM;
 }
 
-static void evm_reset_status(struct inode *inode)
+static void evm_reset_status(struct evm_namespace *ns,
+			     struct inode *inode)
 {
 	struct integrity_iint_cache *iint;
+	struct ima_namespace *ima_ns = NULL;
+	struct ns_status *ns_status;
+
+#ifdef CONFIG_IMA_NS
+	ima_ns = ns->integrity_ns->ima_ns;
+	if (!ima_ns)
+		return;
+#endif
 
 	iint = integrity_iint_find(inode);
-	if (iint)
-		iint->evm_status = INTEGRITY_UNKNOWN;
+	if (!iint)
+		return;
+
+	ns_status = ima_find_ns_status(ima_ns, inode, iint);
+	if (!ns_status)
+		return;
+	ns_status->evm_status = INTEGRITY_UNKNOWN;
 }
 
 /**
@@ -817,7 +834,7 @@ void evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,
 	if (!evm_revalidate_status(ns, xattr_name))
 		return;
 
-	evm_reset_status(dentry->d_inode);
+	evm_reset_status(ns, dentry->d_inode);
 
 	if (!strcmp(xattr_name, XATTR_NAME_EVM))
 		return;
@@ -846,7 +863,7 @@ void evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)
 	if (!evm_revalidate_status(ns, xattr_name))
 		return;
 
-	evm_reset_status(dentry->d_inode);
+	evm_reset_status(ns, dentry->d_inode);
 
 	if (!strcmp(xattr_name, XATTR_NAME_EVM))
 		return;
@@ -938,7 +955,7 @@ void evm_inode_post_setattr(struct dentry *dentry, int ia_valid)
 	if (!evm_revalidate_status(ns, NULL))
 		return;
 
-	evm_reset_status(dentry->d_inode);
+	evm_reset_status(ns, dentry->d_inode);
 
 	if (!(ns->evm_initialized & EVM_INIT_HMAC))
 		return;
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index 483b87de5aae..a2f3235f6e40 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -71,7 +71,6 @@ static void iint_free(struct integrity_iint_cache *iint)
 	iint->version = 0;
 	iint->flags = 0UL;
 	iint->atomic_flags = 0UL;
-	iint->evm_status = INTEGRITY_UNKNOWN;
 	rwlock_init(&iint->ns_list_lock);
 	INIT_LIST_HEAD(&iint->ns_list);
 	kmem_cache_free(iint_cache, iint);
@@ -169,7 +168,6 @@ static void init_once(void *foo)
 	struct integrity_iint_cache *iint = (struct integrity_iint_cache *) foo;
 
 	memset(iint, 0, sizeof(*iint));
-	iint->evm_status = INTEGRITY_UNKNOWN;
 	mutex_init(&iint->mutex);
 	rwlock_init(&iint->ns_list_lock);
 	INIT_LIST_HEAD(&iint->ns_list);
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 1c8f53d9be10..b72c3611e857 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -698,10 +698,6 @@ struct ns_status *ima_get_ns_status(struct ima_namespace *ns,
 				    struct inode *inode,
 				    struct integrity_iint_cache *iint);
 
-struct ns_status *ima_find_ns_status(struct ima_namespace *ns,
-				     struct inode *inode,
-				     struct integrity_iint_cache *iint);
-
 void ima_free_ns_status_tree(struct ima_namespace *ns);
 
 static inline struct ima_namespace *ima_ns_from_file(const struct file *filp)
@@ -756,19 +752,6 @@ static inline struct ns_status *ima_get_ns_status
 	return ns_status;
 }
 
-static inline struct ns_status *ima_find_ns_status
-					(struct ima_namespace *ns,
-					 struct inode *inode,
-					 struct integrity_iint_cache *iint)
-{
-	struct ns_status *ns_status = &iint->ns_status;
-
-	if (list_empty(&iint->ns_list))
-		return NULL;
-
-	return ns_status;
-}
-
 static inline struct ima_namespace *ima_ns_from_file(const struct file *filp)
 {
 	return &init_ima_ns;
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index aaeaf149bb9d..62c3d42d79d6 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -547,7 +547,7 @@ int ima_appraise_measurement(struct ima_namespace *ns, enum ima_hooks func,
 
 	status = evm_verifyxattr(integrity_ns_get_evm_ns(ns->integrity_ns),
 				 dentry, XATTR_NAME_IMA, xattr_value,
-				 rc < 0 ? 0 : rc, iint);
+				 rc < 0 ? 0 : rc, iint, ns_status);
 	switch (status) {
 	case INTEGRITY_PASS:
 	case INTEGRITY_PASS_IMMUTABLE:
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index f54d626ee5b4..80138f71aa85 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -167,6 +167,7 @@ struct ns_status {
 	enum integrity_status ima_bprm_status:4;
 	enum integrity_status ima_read_status:4;
 	enum integrity_status ima_creds_status:4;
+	enum integrity_status evm_status:4;
 #ifdef CONFIG_IMA_NS
 	struct rb_node rb_node;
 	struct integrity_iint_cache *iint;
@@ -189,6 +190,7 @@ static inline void ns_status_reset(struct ns_status *ns_status)
 	ns_status->ima_bprm_status = INTEGRITY_UNKNOWN;
 	ns_status->ima_read_status = INTEGRITY_UNKNOWN;
 	ns_status->ima_creds_status = INTEGRITY_UNKNOWN;
+	ns_status->evm_status = INTEGRITY_UNKNOWN;
 }
 
 static inline void ns_status_init(struct ns_status *ns_status)
@@ -205,7 +207,6 @@ struct integrity_iint_cache {
 	u64 version;		/* track inode changes */
 	unsigned long flags;	/* flags split with ns_status */
 	unsigned long atomic_flags;	/* atomic_flags split with ns_status */
-	enum integrity_status evm_status:4;
 
 	/*
 	 * Lock and list of ns_status for files shared by different
@@ -382,3 +383,26 @@ static inline bool __init trust_moklist(void)
 	return false;
 }
 #endif
+
+// FIXME: this should be integrity_find_ns_status()
+#ifdef CONFIG_IMA_NS
+
+struct ns_status *ima_find_ns_status(struct ima_namespace *ns,
+				     struct inode *inode,
+				     struct integrity_iint_cache *iint);
+
+#else
+
+static inline struct ns_status *ima_find_ns_status
+					(struct ima_namespace *ns,
+					 struct inode *inode,
+					 struct integrity_iint_cache *iint)
+{
+	struct ns_status *ns_status = &iint->ns_status;
+
+	if (list_empty(&iint->ns_list))
+		return NULL;
+
+	return ns_status;
+}
+#endif
-- 
2.40.1

