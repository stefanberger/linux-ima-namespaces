From 12a7780f1ec29fd46d2c7c75c63b3d40a6209997 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Thu, 6 Jan 2022 13:58:00 -0500
Subject: [PATCH 45/63] ima: Namespace all IMA-appraise related iint flags

Namespace all IMA-appraise related iint flags.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 security/integrity/ima/ima.h          |  9 +++++++--
 security/integrity/ima/ima_appraise.c | 25 +++++++++++++++----------
 security/integrity/ima/ima_main.c     |  2 +-
 3 files changed, 23 insertions(+), 13 deletions(-)

diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 892a18070fa9..6a5de1446047 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -584,10 +584,15 @@ static inline int ima_filter_rule_match(u32 secid, u32 field, u32 op,
 #define	POLICY_FILE_FLAGS	S_IWUSR
 #endif /* CONFIG_IMA_READ_POLICY */
 
-#define IMA_NS_STATUS_ACTIONS   (IMA_AUDIT | IMA_MEASURE)
+#define IMA_NS_STATUS_ACTIONS   (IMA_AUDIT | IMA_MEASURE | IMA_APPRAISE)
 #define IMA_NS_STATUS_FLAGS     (IMA_AUDIT | IMA_AUDITED | \
 				 IMA_MEASURE | IMA_MEASURED | IMA_COLLECTED | \
-				 IMA_PERMIT_DIRECTIO)
+				 IMA_PERMIT_DIRECTIO | \
+				 IMA_APPRAISE | IMA_APPRAISED | \
+				 IMA_DIGSIG_REQUIRED | \
+				 IMA_BPRM_APPRAISED | IMA_CREDS_APPRAISED | \
+				 IMA_FILE_APPRAISED | IMA_READ_APPRAISED | \
+				 IMA_MODSIG_ALLOWED | IMA_CHECK_BLACKLIST)
 
 #define IMA_IINT_FLAGS		(IMA_APPRAISE | IMA_HASH)
 
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index c4afdce3d596..c3cf54014a4f 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -152,27 +152,31 @@ static void ima_set_cache_status(struct integrity_iint_cache *iint,
 }
 
 static void ima_cache_flags(struct integrity_iint_cache *iint,
+			    struct ns_status *ns_status,
 			     enum ima_hooks func)
 {
+	unsigned long flags = iint_flags(iint, ns_status);
+
 	switch (func) {
 	case MMAP_CHECK:
-		iint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);
+		flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);
 		break;
 	case BPRM_CHECK:
-		iint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);
+		flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);
 		break;
 	case CREDS_CHECK:
-		iint->flags |= (IMA_CREDS_APPRAISED | IMA_APPRAISED);
+		flags |= (IMA_CREDS_APPRAISED | IMA_APPRAISED);
 		break;
 	case FILE_CHECK:
 	case POST_SETATTR:
-		iint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);
+		flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);
 		break;
 	case MODULE_CHECK ... MAX_CHECK - 1:
 	default:
-		iint->flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);
+		flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);
 		break;
 	}
+	set_iint_flags(iint, ns_status, flags);
 }
 
 enum hash_algo ima_get_hash_algo(struct ima_namespace *ns,
@@ -365,10 +369,10 @@ int ima_check_blacklist(struct ima_namespace *ns,
 	u32 digestsize = 0;
 	int rc = 0;
 
-	if (!(iint->flags & IMA_CHECK_BLACKLIST))
+	if (flags & IMA_CHECK_BLACKLIST)
 		return 0;
 
-	if (iint->flags & IMA_MODSIG_ALLOWED && modsig) {
+	if ((flags & IMA_MODSIG_ALLOWED) && modsig) {
 		ima_get_modsig_digest(modsig, &hash_algo, &digest, &digestsize);
 
 		rc = is_binary_blacklisted(digest, digestsize);
@@ -404,8 +408,9 @@ int ima_appraise_measurement(struct ima_namespace *ns,
 	struct dentry *dentry = file_dentry(file);
 	struct inode *inode = d_backing_inode(dentry);
 	enum integrity_status status = INTEGRITY_UNKNOWN;
+	unsigned long flags = iint_flags(iint, ns_status);
 	int rc = xattr_len;
-	bool try_modsig = iint->flags & IMA_MODSIG_ALLOWED && modsig;
+	bool try_modsig = flags & IMA_MODSIG_ALLOWED && modsig;
 
 	/* If not appraising a modsig, we need an xattr. */
 	if (!(inode->i_opflags & IOP_XATTR) && !try_modsig)
@@ -422,7 +427,7 @@ int ima_appraise_measurement(struct ima_namespace *ns,
 		if (file->f_mode & FMODE_CREATED)
 			iint->flags |= IMA_NEW_FILE;
 		if ((iint->flags & IMA_NEW_FILE) &&
-		    (!(iint->flags & IMA_DIGSIG_REQUIRED) ||
+		    (!(iint_flags(iint, ns_status) & IMA_DIGSIG_REQUIRED) ||
 		     (inode->i_size == 0)))
 			status = INTEGRITY_PASS;
 		goto out;
@@ -502,7 +507,7 @@ int ima_appraise_measurement(struct ima_namespace *ns,
 		integrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,
 				    op, cause, rc, 0);
 	} else {
-		ima_cache_flags(iint, func);
+		ima_cache_flags(iint, ns_status, func);
 	}
 
 	ima_set_cache_status(iint, func, status);
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index d0ada2572b8c..c1b3abc9aa16 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -370,7 +370,7 @@ static int __process_measurement(struct ima_namespace *ns,
 		 * an additional measurement list entry, if needed, based on the
 		 * template format and whether the file was already measured.
 		 */
-		if (iint->flags & IMA_MODSIG_ALLOWED) {
+		if (flags & IMA_MODSIG_ALLOWED) {
 			rc = ima_read_modsig(func, buf, size, &modsig);
 
 			if (!rc && ima_template_has_modsig(template_desc) &&
-- 
2.34.1

