From f5efc529ea64acb475f0880c45ceb0c3f95cd987 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Sun, 2 Jan 2022 00:10:34 -0500
Subject: [PATCH 44/84] ima: Move ima_appraise into ima_namespace

Move ima_appraise into ima_namespace and initialize it for the host
as before and set it to enforcing for IMA namespaces when
CONFIG_IMA_APPRAISE is set.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/ima.h                      |  4 +--
 security/integrity/ima/ima.h             |  5 ++--
 security/integrity/ima/ima_appraise.c    | 16 +++++-------
 security/integrity/ima/ima_fs.c          |  3 +--
 security/integrity/ima/ima_init_ima_ns.c |  7 +++++
 security/integrity/ima/ima_main.c        | 33 ++++++++++--------------
 security/integrity/ima/ima_policy.c      |  7 ++---
 7 files changed, 38 insertions(+), 37 deletions(-)

diff --git a/include/linux/ima.h b/include/linux/ima.h
index 4f269f089aa6..7ef1fd96cfcd 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -187,14 +187,14 @@ static inline void ima_post_key_create_or_update(struct key *keyring,
 #endif  /* CONFIG_IMA_MEASURE_ASYMMETRIC_KEYS */
 
 #ifdef CONFIG_IMA_APPRAISE
-extern bool is_ima_appraise_enabled(void);
+extern bool is_ima_appraise_enabled(struct ima_namespace *ns);
 extern void ima_inode_post_setattr(struct user_namespace *mnt_userns,
 				   struct dentry *dentry);
 extern int ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,
 		       const void *xattr_value, size_t xattr_value_len);
 extern int ima_inode_removexattr(struct dentry *dentry, const char *xattr_name);
 #else
-static inline bool is_ima_appraise_enabled(void)
+static inline bool is_ima_appraise_enabled(struct ima_namespace *ns)
 {
 	return 0;
 }
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 9de017ef36fc..f0e4fe2f1626 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -48,8 +48,6 @@ enum tpm_pcrs { TPM_PCR0 = 0, TPM_PCR8 = 8, TPM_PCR10 = 10 };
 /* bitset of digests algorithms allowed in the setxattr hook */
 extern atomic_t ima_setxattr_allowed_hash_algorithms;
 
-/* set during initialization */
-extern int ima_appraise;
 extern const char boot_aggregate_name[];
 
 /* IMA event related data */
@@ -204,6 +202,9 @@ struct ima_namespace {
 	struct ima_template_desc *ima_buf_template;
 
 	struct integrity_namespace *integrity_ns;
+
+	/* set during initialization */
+	int ima_appraise;
 } __randomize_layout;
 extern struct ima_namespace init_ima_ns;
 
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index 44d8f33be2de..cb1f232d358d 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -28,7 +28,8 @@ void __init ima_appraise_parse_cmdline(void)
 {
 	const char *str = ima_appraise_cmdline_default;
 	bool sb_state = arch_ima_get_secureboot();
-	int appraisal_state = ima_appraise;
+	struct ima_namespace *ns = get_current_ns();
+	int appraisal_state = ns->ima_appraise;
 
 	if (!str)
 		return;
@@ -51,7 +52,7 @@ void __init ima_appraise_parse_cmdline(void)
 			pr_info("Secure boot enabled: ignoring ima_appraise=%s option",
 				str);
 	} else {
-		ima_appraise = appraisal_state;
+		ns->ima_appraise = appraisal_state;
 	}
 }
 #endif
@@ -61,9 +62,9 @@ void __init ima_appraise_parse_cmdline(void)
  *
  * Only return enabled, if not in ima_appraise="fix" or "log" modes.
  */
-bool is_ima_appraise_enabled(void)
+bool is_ima_appraise_enabled(struct ima_namespace *ns)
 {
-	return ima_appraise & IMA_APPRAISE_ENFORCE;
+	return ns->ima_appraise & IMA_APPRAISE_ENFORCE;
 }
 
 /*
@@ -77,10 +78,7 @@ int ima_must_appraise(struct ima_namespace *ns,
 {
 	u32 secid;
 
-	if (ns != &init_ima_ns)
-		return 0;
-
-	if (!ima_appraise)
+	if (!ns->ima_appraise)
 		return 0;
 
 	security_current_getsecid_subj(&secid);
@@ -594,7 +592,7 @@ int ima_appraise_measurement(struct ima_namespace *ns, enum ima_hooks func,
 				    op, cause, rc, 0);
 	} else if (status != INTEGRITY_PASS) {
 		/* Fix mode, but don't replace file signatures. */
-		if ((ima_appraise & IMA_APPRAISE_FIX) && !try_modsig &&
+		if ((ns->ima_appraise & IMA_APPRAISE_FIX) && !try_modsig &&
 		    (!xattr_value ||
 		     xattr_value->type != EVM_IMA_XATTR_DIGSIG)) {
 			if (!ima_fix_xattr(dentry, ns_status))
diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index 86cee141d57a..0b9c9aba2e08 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -369,8 +369,7 @@ static ssize_t ima_write_policy(struct file *file, const char __user *buf,
 
 	if (data[0] == '/') {
 		result = ima_read_policy(user_ns, data);
-	} else if (ns == &init_ima_ns &&
-		   (ima_appraise & IMA_APPRAISE_POLICY)) {
+	} else if (ns->ima_appraise & IMA_APPRAISE_POLICY) {
 		pr_err("signed policy file (specified as an absolute pathname) required\n");
 		integrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,
 				    "policy_update", "signed policy required",
diff --git a/security/integrity/ima/ima_init_ima_ns.c b/security/integrity/ima/ima_init_ima_ns.c
index e2fa5d2bb25c..9fddb6fc808f 100644
--- a/security/integrity/ima/ima_init_ima_ns.c
+++ b/security/integrity/ima/ima_init_ima_ns.c
@@ -45,6 +45,10 @@ int ima_init_namespace(struct ima_namespace *ns, uuid_t *src_userns)
 	else
 		ns->ima_process_keys = true;
 
+#ifdef CONFIG_IMA_APPRAISE
+	ns->ima_appraise = IMA_APPRAISE_ENFORCE;
+#endif
+
 	if (ns != &init_ima_ns) {
 		ns->ima_lsm_policy_notifier.notifier_call =
 						ima_lsm_policy_change;
@@ -111,5 +115,8 @@ struct ima_namespace init_ima_ns = {
 		.template_name = CONFIG_IMA_DEFAULT_TEMPLATE,
 	},
 	.integrity_ns = &init_integrity_ns,
+#ifdef CONFIG_IMA_APPRAISE
+	.ima_appraise = IMA_APPRAISE_ENFORCE,
+#endif
 };
 EXPORT_SYMBOL(init_ima_ns);
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 0365db616d10..742cee1a445a 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -29,12 +29,6 @@
 
 #include "ima.h"
 
-#ifdef CONFIG_IMA_APPRAISE
-int ima_appraise = IMA_APPRAISE_ENFORCE;
-#else
-int ima_appraise;
-#endif
-
 static int __init hash_setup(struct ima_config *ic, char *str)
 {
 	struct ima_namespace *ns = &init_ima_ns;
@@ -451,7 +445,7 @@ static int __process_measurement(struct user_namespace *user_ns,
 	if (pathbuf)
 		__putname(pathbuf);
 	if (must_appraise) {
-		if (rc && (ima_appraise & IMA_APPRAISE_ENFORCE))
+		if (rc && (ns->ima_appraise & IMA_APPRAISE_ENFORCE))
 			return -EACCES;
 		if (file->f_mode & FMODE_WRITE)
 			set_bit(IMA_UPDATE_XATTR, &iint->atomic_flags);
@@ -898,8 +892,8 @@ int ima_post_read_file(struct file *file, void *buf, loff_t size,
 		return 0;
 
 	if (!file || !buf || size == 0) { /* should never happen */
-		if (ns == &init_ima_ns &&
-		    (ima_appraise & IMA_APPRAISE_ENFORCE))
+		if (ns_is_active(ns) &&
+		    ns->ima_appraise & IMA_APPRAISE_ENFORCE)
 			return -EACCES;
 		return 0;
 	}
@@ -927,11 +921,8 @@ int ima_load_data(enum kernel_load_data_id id, bool contents)
 	struct ima_namespace *ns = get_current_ns();
 	bool ima_enforce, sig_enforce;
 
-	if (ns != &init_ima_ns)
-		return 0;
-
 	ima_enforce =
-		(ima_appraise & IMA_APPRAISE_ENFORCE) == IMA_APPRAISE_ENFORCE;
+	    (ns->ima_appraise & IMA_APPRAISE_ENFORCE) == IMA_APPRAISE_ENFORCE;
 
 	switch (id) {
 	case LOADING_KEXEC_IMAGE:
@@ -941,13 +932,14 @@ int ima_load_data(enum kernel_load_data_id id, bool contents)
 			return -EACCES;
 		}
 
-		if (ima_enforce && (ima_appraise & IMA_APPRAISE_KEXEC)) {
+		if (ima_enforce && (ns->ima_appraise & IMA_APPRAISE_KEXEC)) {
 			pr_err("impossible to appraise a kernel image without a file descriptor; try using kexec_file_load syscall.\n");
 			return -EACCES;	/* INTEGRITY_UNKNOWN */
 		}
 		break;
 	case LOADING_FIRMWARE:
-		if (ima_enforce && (ima_appraise & IMA_APPRAISE_FIRMWARE) && !contents) {
+		if (ima_enforce &&
+		    (ns->ima_appraise & IMA_APPRAISE_FIRMWARE) && !contents) {
 			pr_err("Prevent firmware sysfs fallback loading.\n");
 			return -EACCES;	/* INTEGRITY_UNKNOWN */
 		}
@@ -955,8 +947,9 @@ int ima_load_data(enum kernel_load_data_id id, bool contents)
 	case LOADING_MODULE:
 		sig_enforce = is_module_sig_enforced();
 
-		if (ima_enforce && (!sig_enforce
-				    && (ima_appraise & IMA_APPRAISE_MODULES))) {
+		if (ima_enforce &&
+		    (!sig_enforce &&
+		     (ns->ima_appraise & IMA_APPRAISE_MODULES))) {
 			pr_err("impossible to appraise a module without a file descriptor. sig_enforce kernel parameter might help\n");
 			return -EACCES;	/* INTEGRITY_UNKNOWN */
 		}
@@ -984,9 +977,11 @@ int ima_post_load_data(char *buf, loff_t size,
 		       enum kernel_load_data_id load_id,
 		       char *description)
 {
+	struct ima_namespace *ns = get_current_ns();
+
 	if (load_id == LOADING_FIRMWARE) {
-		if ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&
-		    (ima_appraise & IMA_APPRAISE_ENFORCE)) {
+		if ((ns->ima_appraise & IMA_APPRAISE_FIRMWARE) &&
+		    (ns->ima_appraise & IMA_APPRAISE_ENFORCE)) {
 			pr_err("Prevent firmware loading_store.\n");
 			return -EACCES; /* INTEGRITY_UNKNOWN */
 		}
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index b699c196b6e2..4c7aa0fb5034 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -809,8 +809,8 @@ void ima_update_policy_flags(struct ima_namespace *ns)
 	}
 	rcu_read_unlock();
 
-	ima_appraise |= (build_ima_appraise | temp_ima_appraise);
-	if (!ima_appraise)
+	ns->ima_appraise |= (build_ima_appraise | temp_ima_appraise);
+	if (!ns->ima_appraise)
 		new_policy_flag &= ~IMA_APPRAISE;
 
 	ns->ima_policy_flag = new_policy_flag;
@@ -2354,7 +2354,8 @@ bool ima_appraise_signature(enum kernel_read_file_id id)
 	if (id >= READING_MAX_ID)
 		return false;
 
-	if (id == READING_KEXEC_IMAGE && !(ima_appraise & IMA_APPRAISE_ENFORCE)
+	if (id == READING_KEXEC_IMAGE
+	    && !(ns->ima_appraise & IMA_APPRAISE_ENFORCE)
 	    && security_locked_down(LOCKDOWN_KEXEC))
 		return false;
 
-- 
2.37.3

