From 8abfd06c41919b57fde3f908e46c99c1a83a7ce8 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Fri, 20 May 2022 15:53:15 -0400
Subject: [PATCH 77/81] integrity/evm: Move evm_status from iint cache into
 ns_status

To be able to track the evm_status on a per namespace basis move the
evm_status variable from the integrity_iint_cache into the ns_status
structure.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/evm.h                   |  4 ++-
 security/integrity/evm/evm_main.c     | 47 ++++++++++++++++++---------
 security/integrity/iint.c             |  2 --
 security/integrity/ima/ima_appraise.c |  3 +-
 security/integrity/integrity.h        |  3 +-
 5 files changed, 39 insertions(+), 20 deletions(-)

diff --git a/include/linux/evm.h b/include/linux/evm.h
index cc395647874f..2e0982bfc002 100644
--- a/include/linux/evm.h
+++ b/include/linux/evm.h
@@ -16,6 +16,7 @@
 
 struct integrity_iint_cache;
 struct integrity_namespace;
+struct ns_status;
 
 struct evm_namespace {
 	unsigned long evm_ns_flags;
@@ -64,7 +65,8 @@ extern enum integrity_status evm_verifyxattr(struct evm_namespace *ns,
 					     const char *xattr_name,
 					     void *xattr_value,
 					     size_t xattr_value_len,
-					     struct integrity_iint_cache *iint);
+					     struct integrity_iint_cache *iint,
+					     struct ns_status *ns_status);
 extern int evm_inode_setattr(struct dentry *dentry, struct iattr *attr);
 extern void evm_inode_post_setattr(struct dentry *dentry,
 				   int ia_valid);
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index 90de08780f8a..3a5294786230 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -223,7 +223,8 @@ static enum integrity_status evm_verify_hmac(struct evm_namespace *ns,
 					     const char *xattr_name,
 					     char *xattr_value,
 					     size_t xattr_value_len,
-					     struct integrity_iint_cache *iint)
+					     struct integrity_iint_cache *iint,
+					     struct ns_status *ns_status)
 {
 	struct evm_ima_xattr_data *xattr_data = NULL;
 	struct signature_v2_hdr *hdr;
@@ -232,9 +233,9 @@ static enum integrity_status evm_verify_hmac(struct evm_namespace *ns,
 	struct inode *inode;
 	int rc, xattr_len, evm_immutable = 0;
 
-	if (iint && (iint->evm_status == INTEGRITY_PASS ||
-		     iint->evm_status == INTEGRITY_PASS_IMMUTABLE))
-		return iint->evm_status;
+	if (ns_status && (ns_status->evm_status == INTEGRITY_PASS ||
+		          ns_status->evm_status == INTEGRITY_PASS_IMMUTABLE))
+		return ns_status->evm_status;
 
 	/* if status is not PASS, try to check again - against -ENOMEM */
 
@@ -328,8 +329,8 @@ static enum integrity_status evm_verify_hmac(struct evm_namespace *ns,
 	pr_debug("digest: (%d) [%*phN]\n", digest.hdr.length, digest.hdr.length,
 		  digest.digest);
 out:
-	if (iint)
-		iint->evm_status = evm_status;
+	if (ns_status)
+		ns_status->evm_status = evm_status;
 	kfree(xattr_data);
 	return evm_status;
 }
@@ -470,7 +471,8 @@ enum integrity_status evm_verifyxattr(struct evm_namespace *ns,
 				      struct dentry *dentry,
 				      const char *xattr_name,
 				      void *xattr_value, size_t xattr_value_len,
-				      struct integrity_iint_cache *iint)
+				      struct integrity_iint_cache *iint,
+				      struct ns_status *ns_status)
 {
 	if (!evm_key_loaded(ns) || !evm_protected_xattr(ns, xattr_name))
 		return INTEGRITY_UNKNOWN;
@@ -481,7 +483,7 @@ enum integrity_status evm_verifyxattr(struct evm_namespace *ns,
 			return INTEGRITY_UNKNOWN;
 	}
 	return evm_verify_hmac(ns, dentry, xattr_name, xattr_value,
-				 xattr_value_len, iint);
+				 xattr_value_len, iint, ns_status);
 }
 EXPORT_SYMBOL_GPL(evm_verifyxattr);
 
@@ -499,7 +501,7 @@ static enum integrity_status evm_verify_current_integrity
 
 	if (!evm_key_loaded(ns) || !S_ISREG(inode->i_mode) || evm_fixmode)
 		return INTEGRITY_PASS;
-	return evm_verify_hmac(ns, dentry, NULL, NULL, 0, NULL);
+	return evm_verify_hmac(ns, dentry, NULL, NULL, 0, NULL, NULL);
 }
 
 /*
@@ -735,13 +737,28 @@ int evm_inode_removexattr(struct user_namespace *mnt_userns,
 	return evm_protect_xattr(ns, mnt_userns, dentry, xattr_name, NULL, 0);
 }
 
-static void evm_reset_status(struct inode *inode)
+static void evm_reset_status(struct evm_namespace *ns,
+			     struct inode *inode)
 {
 	struct integrity_iint_cache *iint;
+	struct ima_namespace *ima_ns = ns->integrity_ns->ima_ns;
+	struct ns_status *ns_status;
+
+	if (!ima_ns)
+		return;
 
 	iint = integrity_iint_find(inode);
-	if (iint)
-		iint->evm_status = INTEGRITY_UNKNOWN;
+	if (!iint)
+		return;
+
+#if 0	// FIXME
+	ns_status = ima_ns_status_find(ima_ns, inode);
+#else
+	ns_status = NULL;
+#endif
+	if (!ns_status)
+		return;
+	ns_status->evm_status = INTEGRITY_UNKNOWN;
 }
 
 /**
@@ -792,7 +809,7 @@ void evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,
 	if (!evm_revalidate_status(ns, xattr_name))
 		return;
 
-	evm_reset_status(dentry->d_inode);
+	evm_reset_status(ns, dentry->d_inode);
 
 	if (!strcmp(xattr_name, XATTR_NAME_EVM))
 		return;
@@ -821,7 +838,7 @@ void evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)
 	if (!evm_revalidate_status(ns, xattr_name))
 		return;
 
-	evm_reset_status(dentry->d_inode);
+	evm_reset_status(ns, dentry->d_inode);
 
 	if (!strcmp(xattr_name, XATTR_NAME_EVM))
 		return;
@@ -909,7 +926,7 @@ void evm_inode_post_setattr(struct dentry *dentry, int ia_valid)
 	if (!evm_revalidate_status(ns, NULL))
 		return;
 
-	evm_reset_status(dentry->d_inode);
+	evm_reset_status(ns, dentry->d_inode);
 
 	if (!(ns->evm_initialized & EVM_INIT_HMAC))
 		return;
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index 9f240c45edc5..ad264dee95d2 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -73,7 +73,6 @@ static void iint_free(struct integrity_iint_cache *iint)
 	iint->version = 0;
 	iint->flags = 0UL;
 	iint->atomic_flags = 0UL;
-	iint->evm_status = INTEGRITY_UNKNOWN;
 	rwlock_init(&iint->ns_list_lock);
 	INIT_LIST_HEAD(&iint->ns_list);
 	kmem_cache_free(iint_cache, iint);
@@ -174,7 +173,6 @@ static void init_once(void *foo)
 	struct integrity_iint_cache *iint = (struct integrity_iint_cache *) foo;
 
 	memset(iint, 0, sizeof(*iint));
-	iint->evm_status = INTEGRITY_UNKNOWN;
 	mutex_init(&iint->mutex);
 	rwlock_init(&iint->ns_list_lock);
 	INIT_LIST_HEAD(&iint->ns_list);
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index 9692b7c47f93..6aa61898b4c4 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -435,7 +435,8 @@ int ima_appraise_measurement(struct ima_namespace *ns,
 
 	status = evm_verifyxattr(integrity_ns_get_evm_ns(ns->integrity_ns),
 				 dentry,
-				 XATTR_NAME_IMA, xattr_value, rc, iint);
+				 XATTR_NAME_IMA, xattr_value, rc,
+				 iint, ns_status);
 	switch (status) {
 	case INTEGRITY_PASS:
 	case INTEGRITY_PASS_IMMUTABLE:
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index 8a176a948918..886eeb626df1 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -143,6 +143,7 @@ struct ns_status {
 	enum integrity_status ima_bprm_status:4;
 	enum integrity_status ima_read_status:4;
 	enum integrity_status ima_creds_status:4;
+	enum integrity_status evm_status:4;
 #ifdef CONFIG_IMA_NS
 	struct rb_node rb_node;
 	struct integrity_iint_cache *iint;
@@ -164,6 +165,7 @@ static inline void ns_status_reset(struct ns_status *ns_status)
 	ns_status->ima_bprm_status = INTEGRITY_UNKNOWN;
 	ns_status->ima_read_status = INTEGRITY_UNKNOWN;
 	ns_status->ima_creds_status = INTEGRITY_UNKNOWN;
+	ns_status->evm_status = INTEGRITY_UNKNOWN;
 }
 
 static inline void ns_status_init(struct ns_status *ns_status)
@@ -180,7 +182,6 @@ struct integrity_iint_cache {
 	u64 version;		/* track inode changes */
 	unsigned long flags;	/* flags split with ns_status */
 	unsigned long atomic_flags;
-	enum integrity_status evm_status:4;
 
 	/*
 	 * Lock and list of ns_status for files shared by different
-- 
2.35.1

