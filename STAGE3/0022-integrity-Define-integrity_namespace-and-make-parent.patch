From 5dd27a1a3a9133a090753456f78f08b790a47469 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Mon, 24 Jan 2022 20:53:10 -0500
Subject: [PATCH 22/40] integrity: Define integrity_namespace and make parent
 of ima_namespace

Define an integrity_namespace and make it a parent of the ima_namespace.

The user_namespace will have a pointer to the IMA namespace right from
the beginning.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/ima.h                 |  3 +-
 include/linux/integrity_namespace.h | 36 ++++++++++++++++++++++
 include/linux/user_namespace.h      |  4 +--
 kernel/user.c                       |  4 +--
 kernel/user_namespace.c             | 18 +++++++++--
 security/integrity/Makefile         |  2 +-
 security/integrity/ima/ima.h        |  9 ++++--
 security/integrity/ima/ima_ns.c     |  2 +-
 security/integrity/integrity_ns.c   | 46 +++++++++++++++++++++++++++++
 9 files changed, 112 insertions(+), 12 deletions(-)
 create mode 100644 include/linux/integrity_namespace.h
 create mode 100644 security/integrity/integrity_ns.c

diff --git a/include/linux/ima.h b/include/linux/ima.h
index 7bf67cc35ef7..d7f8e1d3ec4e 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -12,6 +12,7 @@
 #include <linux/security.h>
 #include <linux/kexec.h>
 #include <linux/user_namespace.h>
+#include <linux/integrity_namespace.h>
 #include <crypto/hash_info.h>
 struct linux_binprm;
 
@@ -76,7 +77,7 @@ static inline struct user_namespace
 
 	user_ns = current_user_ns();
 #ifdef CONFIG_IMA_NS
-	WARN_ON(user_ns->ima_ns != ns);
+	WARN_ON(user_ns->integrity_ns->ima_ns != ns);
 #endif
 	return user_ns;
 }
diff --git a/include/linux/integrity_namespace.h b/include/linux/integrity_namespace.h
new file mode 100644
index 000000000000..41530a253cec
--- /dev/null
+++ b/include/linux/integrity_namespace.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2021 IBM Corporation
+ * Author: Stefan Berger <stefanb@us.ibm.com>
+ */
+
+#ifndef _LINUX_INTEGRITY_NAMESPACE_H
+#define _LINUX_INTEGRITY_NAMESPACE_H
+
+struct ima_namespace;
+
+struct integrity_namespace {
+	struct ima_namespace *ima_ns;
+};
+extern struct integrity_namespace init_integrity_ns;
+
+
+#ifdef CONFIG_IMA_NS
+
+struct integrity_namespace *create_integrity_ns(void);
+extern void free_integrity_ns(struct user_namespace *user_ns);
+
+#else
+
+static inline struct integrity_namespace *create_integrity_ns(void)
+{
+	return NULL;
+}
+
+static inline void free_integrity_ns(struct user_namespace *user_ns)
+{
+}
+
+#endif
+
+#endif /* _LINUX_INTEGRITY_NAMESPACE_H */
diff --git a/include/linux/user_namespace.h b/include/linux/user_namespace.h
index 019e8cf7b633..cd9e8ee54918 100644
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@ -36,7 +36,7 @@ struct uid_gid_map { /* 64 bytes -- 1 cache line */
 #define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED
 
 struct ucounts;
-struct ima_namespace;
+struct integrity_namespace;
 
 enum ucount_type {
 	UCOUNT_USER_NAMESPACES,
@@ -101,7 +101,7 @@ struct user_namespace {
 	struct ucounts		*ucounts;
 	long ucount_max[UCOUNT_COUNTS];
 #ifdef CONFIG_IMA_NS
-	struct ima_namespace	*ima_ns;
+	struct integrity_namespace *integrity_ns;
 #endif
 } __randomize_layout;
 
diff --git a/kernel/user.c b/kernel/user.c
index e5d1f4b9b8ba..1adcdf581907 100644
--- a/kernel/user.c
+++ b/kernel/user.c
@@ -19,7 +19,7 @@
 #include <linux/export.h>
 #include <linux/user_namespace.h>
 #include <linux/proc_ns.h>
-#include <linux/ima.h>
+#include <linux/integrity_namespace.h>
 
 /*
  * userns count is 1 for root user, 1 for init_uts_ns,
@@ -69,7 +69,7 @@ struct user_namespace init_user_ns = {
 	.keyring_sem = __RWSEM_INITIALIZER(init_user_ns.keyring_sem),
 #endif
 #ifdef CONFIG_IMA_NS
-	.ima_ns = &init_ima_ns,
+	.integrity_ns = &init_integrity_ns,
 #endif
 };
 EXPORT_SYMBOL_GPL(init_user_ns);
diff --git a/kernel/user_namespace.c b/kernel/user_namespace.c
index 653f8fa83b69..f2821b7dc79d 100644
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@ -20,7 +20,7 @@
 #include <linux/fs_struct.h>
 #include <linux/bsearch.h>
 #include <linux/sort.h>
-#include <linux/ima.h>
+#include <linux/integrity_namespace.h>
 
 static struct kmem_cache *user_ns_cachep __read_mostly;
 static DEFINE_MUTEX(userns_state_mutex);
@@ -142,8 +142,22 @@ int create_user_ns(struct cred *new)
 	if (!setup_userns_sysctls(ns))
 		goto fail_keyring;
 
+#ifdef CONFIG_IMA_NS
+	ns->integrity_ns = create_integrity_ns();
+	if (IS_ERR(ns->integrity_ns)) {
+		ret = PTR_ERR(ns->integrity_ns);
+		goto fail_userns_sysctls;
+	}
+#endif
+
 	set_cred_user_ns(new, ns);
 	return 0;
+
+#ifdef CONFIG_IMA_NS
+fail_userns_sysctls:
+	retire_userns_sysctls(ns);
+#endif
+
 fail_keyring:
 #ifdef CONFIG_PERSISTENT_KEYRINGS
 	key_put(ns->persistent_keyring_register);
@@ -197,7 +211,7 @@ static void free_user_ns(struct work_struct *work)
 			kfree(ns->projid_map.forward);
 			kfree(ns->projid_map.reverse);
 		}
-		free_ima_ns(ns);
+		free_integrity_ns(ns);
 		retire_userns_sysctls(ns);
 		key_free_user_ns(ns);
 		ns_free_inum(&ns->ns);
diff --git a/security/integrity/Makefile b/security/integrity/Makefile
index 7ee39d66cf16..ee30f1a3f13d 100644
--- a/security/integrity/Makefile
+++ b/security/integrity/Makefile
@@ -5,7 +5,7 @@
 
 obj-$(CONFIG_INTEGRITY) += integrity.o
 
-integrity-y := iint.o
+integrity-y := iint.o integrity_ns.o
 integrity-$(CONFIG_INTEGRITY_AUDIT) += integrity_audit.o
 integrity-$(CONFIG_INTEGRITY_SIGNATURE) += digsig.o
 integrity-$(CONFIG_INTEGRITY_ASYMMETRIC_KEYS) += digsig_asymmetric.o
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index ed936b492de5..47fbc8bc0dcb 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -21,6 +21,7 @@
 #include <linux/tpm.h>
 #include <linux/audit.h>
 #include <linux/user_namespace.h>
+#include <linux/integrity_namespace.h>
 #include <crypto/hash_info.h>
 
 #include "../integrity.h"
@@ -70,6 +71,8 @@ struct ima_field_data {
 	u32 len;
 };
 
+struct ima_namespace;
+
 /* IMA template field definition */
 struct ima_template_field {
 	const char field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN];
@@ -598,14 +601,14 @@ static inline struct ima_namespace
 *ima_ns_from_user_ns(struct user_namespace *user_ns)
 {
 	/* Pairs with smp_store_releases() in user_ns_set_ima_ns(). */
-	return smp_load_acquire(&user_ns->ima_ns);
+	return smp_load_acquire(&user_ns->integrity_ns->ima_ns);
 }
 
 static inline void user_ns_set_ima_ns(struct user_namespace *user_ns,
 				      struct ima_namespace *ns)
 {
 	/* Pairs with smp_load_acquire() in ima_ns_from_user_ns() */
-	smp_store_release(&user_ns->ima_ns, ns);
+	smp_store_release(&user_ns->integrity_ns->ima_ns, ns);
 }
 
 static inline struct ima_namespace *get_current_ns(void)
@@ -625,7 +628,7 @@ void ima_free_ns_status_tree(struct ima_namespace *ns);
 
 static inline struct ima_namespace *ima_ns_from_file(const struct file *filp)
 {
-	return ima_user_ns_from_file(filp)->ima_ns;
+	return ima_user_ns_from_file(filp)->integrity_ns->ima_ns;
 }
 
 #else
diff --git a/security/integrity/ima/ima_ns.c b/security/integrity/ima/ima_ns.c
index 57eecb469742..1427a1daa867 100644
--- a/security/integrity/ima/ima_ns.c
+++ b/security/integrity/ima/ima_ns.c
@@ -70,7 +70,7 @@ void free_ima_ns(struct user_namespace *user_ns)
 
 	ima_free_ima_ns(ns);
 
-	user_ns->ima_ns = NULL;
+	user_ns->integrity_ns->ima_ns = NULL;
 }
 
 static int __init imans_cache_init(void)
diff --git a/security/integrity/integrity_ns.c b/security/integrity/integrity_ns.c
new file mode 100644
index 000000000000..f1756a0f07b9
--- /dev/null
+++ b/security/integrity/integrity_ns.c
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2021 IBM Corporation
+ *
+ * Authors:
+ * Stefan Berger <stefanb@us.ibm.com>
+ */
+
+#include <linux/ima.h>
+#include <linux/integrity_namespace.h>
+
+struct integrity_namespace init_integrity_ns = {
+	.ima_ns = &init_ima_ns,
+};
+EXPORT_SYMBOL(init_integrity_ns);
+
+#ifdef CONFIG_IMA_NS
+
+static struct kmem_cache *integrityns_cachep;
+
+struct integrity_namespace *create_integrity_ns(void)
+{
+	struct integrity_namespace *ns;
+
+	ns = kmem_cache_zalloc(integrityns_cachep, GFP_KERNEL);
+	if (!ns)
+		return ERR_PTR(-ENOMEM);
+ 
+	return ns;
+}
+
+void free_integrity_ns(struct user_namespace *user_ns)
+{
+	free_ima_ns(user_ns);
+
+	kmem_cache_free(integrityns_cachep, ns);
+}
+
+static int __init integrityns_cache_init(void)
+{
+	integrityns_cachep = KMEM_CACHE(integrity_namespace, SLAB_PANIC);
+	return 0;
+}
+subsys_initcall(integrityns_cache_init)
+
+#endif
-- 
2.31.1

