From b30d9ce92f9626f8c1af8d950c90d5bf680d36aa Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Mon, 3 Jan 2022 21:05:55 -0500
Subject: [PATCH 20/20] integrity: Move integrity_dir into integrity_namespace

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/integrity_namespace.h      |  5 ++++-
 security/integrity/evm/evm.h             |  2 +-
 security/integrity/evm/evm_main.c        |  2 +-
 security/integrity/evm/evm_secfs.c       |  5 +++--
 security/integrity/iint.c                | 26 ++++++++++++++++--------
 security/integrity/ima/ima.h             |  5 +++--
 security/integrity/ima/ima_fs.c          | 15 ++++----------
 security/integrity/ima/ima_init_ima_ns.c |  9 +++++---
 security/integrity/ima/ima_ns.c          |  5 +++--
 security/integrity/integrity.h           |  5 +++--
 security/integrity/integrity_ns.c        | 14 ++++++++++++-
 11 files changed, 59 insertions(+), 34 deletions(-)

diff --git a/include/linux/integrity_namespace.h b/include/linux/integrity_namespace.h
index 28facf03e397..19a79f171b3e 100644
--- a/include/linux/integrity_namespace.h
+++ b/include/linux/integrity_namespace.h
@@ -18,10 +18,11 @@
 struct integrity_namespace {
 	struct key *keyring[INTEGRITY_KEYRING_MAX];
 	const char *keyring_name[INTEGRITY_KEYRING_MAX];
+	struct dentry *integrity_dir;
 };
 extern struct integrity_namespace init_integrity_ns;
 
-struct integrity_namespace *integrity_create_ns(void);
+struct integrity_namespace *integrity_create_ns(struct dentry *secfs_root);
 void integrity_free_ns(struct integrity_namespace *ns);
 
 
@@ -111,6 +112,8 @@ static inline struct ima_namespace *current_ima_ns(void)
 static inline struct integrity_namespace *current_integrity_ns(void)
 {
 	struct ima_namespace *ns = current_ima_ns();
+	if (!ns)
+		return NULL; // this is possible!
 	return ns->integrity_ns;
 }
 
diff --git a/security/integrity/evm/evm.h b/security/integrity/evm/evm.h
index 0d44f41d16f8..10d5ac575682 100644
--- a/security/integrity/evm/evm.h
+++ b/security/integrity/evm/evm.h
@@ -63,6 +63,6 @@ int evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,
 		  struct evm_digest *data);
 int evm_init_hmac(struct inode *inode, const struct xattr *xattr,
 		  char *hmac_val);
-int evm_init_secfs(void);
+int evm_init_secfs(struct integrity_namespace *ns);
 
 #endif
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index 951c1971f70e..3349c4141c17 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -899,7 +899,7 @@ static int __init init_evm(void)
 	if (error)
 		goto error;
 
-	error = evm_init_secfs();
+	error = evm_init_secfs(&init_integrity_ns);
 	if (error < 0) {
 		pr_info("Error registering secfs\n");
 		goto error;
diff --git a/security/integrity/evm/evm_secfs.c b/security/integrity/evm/evm_secfs.c
index 8a9db7dfca7e..cb879067eba1 100644
--- a/security/integrity/evm/evm_secfs.c
+++ b/security/integrity/evm/evm_secfs.c
@@ -14,6 +14,7 @@
 #include <linux/uaccess.h>
 #include <linux/init.h>
 #include <linux/mutex.h>
+#include <linux/integrity_namespace.h>
 #include "evm.h"
 
 static struct dentry *evm_dir;
@@ -298,11 +299,11 @@ static int evm_init_xattrs(void)
 }
 #endif
 
-int __init evm_init_secfs(void)
+int __init evm_init_secfs(struct integrity_namespace *ns)
 {
 	int error = 0;
 
-	evm_dir = securityfs_create_dir("evm", integrity_dir);
+	evm_dir = securityfs_create_dir("evm", ns->integrity_dir);
 	if (!evm_dir || IS_ERR(evm_dir))
 		return -EFAULT;
 
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index 508171fa482b..9c94a2026f92 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -20,14 +20,13 @@
 #include <linux/security.h>
 #include <linux/lsm_hooks.h>
 #include <linux/ima.h>
+#include <linux/integrity_namespace.h>
 #include "integrity.h"
 
 static struct rb_root integrity_iint_tree = RB_ROOT;
 static DEFINE_RWLOCK(integrity_iint_lock);
 static struct kmem_cache *iint_cache __read_mostly;
 
-struct dentry *integrity_dir;
-
 /*
  * __integrity_iint_find - return the iint associated with an inode
  */
@@ -228,20 +227,31 @@ void __init integrity_load_keys(void)
 		evm_load_x509();
 }
 
-static int __init integrity_fs_init(void)
+void integrity_fs_free(struct integrity_namespace *ns)
+{
+	securityfs_remove(ns->integrity_dir);
+}
+
+int integrity_fs_init(struct integrity_namespace *ns,
+		      struct dentry *secfs_root)
 {
-	integrity_dir = securityfs_create_dir("integrity", NULL);
-	if (IS_ERR(integrity_dir)) {
-		int ret = PTR_ERR(integrity_dir);
+	ns->integrity_dir = securityfs_create_dir("integrity", secfs_root);
+	if (IS_ERR(ns->integrity_dir)) {
+		int ret = PTR_ERR(ns->integrity_dir);
 
 		if (ret != -ENODEV)
 			pr_err("Unable to create integrity sysfs dir: %d\n",
 			       ret);
-		integrity_dir = NULL;
+		ns->integrity_dir = NULL;
 		return ret;
 	}
 
 	return 0;
 }
 
-late_initcall(integrity_fs_init)
+static int __init init_integrity_ns_fs_init(void)
+{
+	return integrity_fs_init(&init_integrity_ns, NULL);
+}
+
+late_initcall(init_integrity_ns_fs_init)
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index b28c91e1d306..4f93ab4bbc12 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -141,7 +141,7 @@ struct ns_status {
 int ima_init(void);
 int ima_fs_init(void);
 int ima_ns_init(void);
-int ima_init_namespace(struct ima_namespace *ns);
+int ima_init_namespace(struct ima_namespace *ns, struct dentry *secfs_root);
 int ima_add_template_entry(struct ima_namespace *ns,
 			   struct ima_template_entry *entry, int violation,
 			   const char *op, struct inode *inode,
@@ -497,7 +497,8 @@ static inline struct ima_namespace *get_current_ns(void)
 	return ima_ns_from_user_ns(current_user_ns());
 }
 
-struct ima_namespace *create_ima_ns(struct user_namespace *user_ns);
+struct ima_namespace *create_ima_ns(struct user_namespace *user_ns,
+				    struct dentry *secfs_root);
 
 struct ns_status *ima_get_ns_status(struct ima_namespace *ns,
 				    struct inode *inode,
diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index c02e09a635f6..d8e7f719c906 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -22,6 +22,7 @@
 #include <linux/parser.h>
 #include <linux/vmalloc.h>
 #include <linux/ima.h>
+#include <linux/integrity.h>
 
 #include "ima.h"
 
@@ -473,23 +474,17 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 	 * user_ns->ima_ns can't change while we're in here.
 	 */
 	if (!ns) {
-		ns = create_ima_ns(user_ns);
+		ns = create_ima_ns(user_ns, root);
 		if (IS_ERR(ns))
 			return PTR_ERR(ns);
 		created_ns = true;
 	}
 
-	/* FIXME: update when evm and integrity are namespaced */
-	if (user_ns != &init_user_ns) {
-		int_dir = securityfs_create_dir("integrity", root);
-		if (IS_ERR(int_dir))
-			goto free_ns;
-	} else
-		int_dir = integrity_dir;
+	int_dir = ns->integrity_ns->integrity_dir;
 
 	ima_dir = securityfs_create_dir("ima", int_dir);
 	if (IS_ERR(ima_dir))
-		goto out;
+		goto free_ns;
 
 	ima_symlink = securityfs_create_symlink("ima", root, "integrity/ima",
 						NULL);
@@ -542,8 +537,6 @@ int ima_fs_ns_init(struct user_namespace *user_ns, struct dentry *root)
 	securityfs_remove(binary_runtime_measurements);
 	securityfs_remove(ima_symlink);
 	securityfs_remove(ima_dir);
-	if (user_ns != &init_user_ns)
-		securityfs_remove(int_dir);
 
 free_ns:
 	if (created_ns)
diff --git a/security/integrity/ima/ima_init_ima_ns.c b/security/integrity/ima/ima_init_ima_ns.c
index ca69a337a3c3..3634bb0285cf 100644
--- a/security/integrity/ima/ima_init_ima_ns.c
+++ b/security/integrity/ima/ima_init_ima_ns.c
@@ -8,7 +8,8 @@
 
 #include "ima.h"
 
-int ima_init_namespace(struct ima_namespace *ns)
+int ima_init_namespace(struct ima_namespace *ns,
+		       struct dentry *secfs_root)
 {
 	int rc;
 
@@ -38,7 +39,7 @@ int ima_init_namespace(struct ima_namespace *ns)
 	ns->ima_fs_flags = 0;
 
 	if (ns != &init_ima_ns) {
-		ns->integrity_ns = integrity_create_ns();
+		ns->integrity_ns = integrity_create_ns(secfs_root);
 		if (IS_ERR(ns->integrity_ns))
 			return PTR_ERR(ns->integrity_ns);
 	}
@@ -84,12 +85,14 @@ int ima_init_namespace(struct ima_namespace *ns)
 	ima_deinit_crypto(ns);
 
 error:
+	integrity_free_ns(ns->integrity_ns);
+
 	return rc;
 }
 
 int __init ima_ns_init(void)
 {
-	return ima_init_namespace(&init_ima_ns);
+	return ima_init_namespace(&init_ima_ns, NULL);
 }
 
 struct ima_namespace init_ima_ns = {
diff --git a/security/integrity/ima/ima_ns.c b/security/integrity/ima/ima_ns.c
index 3ef8fad72bff..dc96d4f377fe 100644
--- a/security/integrity/ima/ima_ns.c
+++ b/security/integrity/ima/ima_ns.c
@@ -12,7 +12,8 @@
 
 static struct kmem_cache *imans_cachep;
 
-struct ima_namespace *create_ima_ns(struct user_namespace *user_ns)
+struct ima_namespace *create_ima_ns(struct user_namespace *user_ns,
+				    struct dentry *secfs_root)
 {
 	struct ima_namespace *ns;
 	int err;
@@ -22,7 +23,7 @@ struct ima_namespace *create_ima_ns(struct user_namespace *user_ns)
 		return ERR_PTR(-ENOMEM);
 	pr_debug("NEW     ima_ns: %p\n", ns);
 
-	err = ima_init_namespace(ns);
+	err = ima_init_namespace(ns, secfs_root);
 	if (err)
 		goto fail_free;
 
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index 3202d3079df7..072670143ab4 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -151,11 +151,12 @@ struct integrity_iint_cache *integrity_iint_find(struct inode *inode);
 int integrity_kernel_read(struct file *file, loff_t offset,
 			  void *addr, unsigned long count);
 
-extern struct dentry *integrity_dir;
-
 struct modsig;
 struct integrity_namespace;
 
+int integrity_fs_init(struct integrity_namespace *ns, struct dentry *root);
+void integrity_fs_free(struct integrity_namespace *ns);
+
 #ifdef CONFIG_INTEGRITY_SIGNATURE
 
 int integrity_digsig_verify(struct integrity_namespace *ns,
diff --git a/security/integrity/integrity_ns.c b/security/integrity/integrity_ns.c
index 14f5644b3505..c3deb38ce913 100644
--- a/security/integrity/integrity_ns.c
+++ b/security/integrity/integrity_ns.c
@@ -9,6 +9,8 @@
 #include <linux/slab.h>
 #include <linux/integrity_namespace.h>
 
+#include "integrity.h"
+
 static struct kmem_cache *integrityns_cachep;
 
 struct integrity_namespace init_integrity_ns = {
@@ -26,9 +28,10 @@ struct integrity_namespace init_integrity_ns = {
 };
 EXPORT_SYMBOL(init_integrity_ns);
 
-struct integrity_namespace *integrity_create_ns(void)
+struct integrity_namespace *integrity_create_ns(struct dentry *root)
 {
 	struct integrity_namespace *ns;
+	int ret;
 
 	ns = kmem_cache_zalloc(integrityns_cachep, GFP_KERNEL);
 	if (!ns)
@@ -38,11 +41,20 @@ struct integrity_namespace *integrity_create_ns(void)
 	ns->keyring_name[INTEGRITY_KEYRING_IMA] = "_ima";
 	ns->keyring_name[INTEGRITY_KEYRING_PLATFORM] = "";
 
+	ret = integrity_fs_init(ns, root);
+	if (ret)
+		goto err_free_ns;
+
 	return ns;
+
+err_free_ns:
+	kmem_cache_free(integrityns_cachep, ns);
+	return ERR_PTR(ret);
 }
 
 void integrity_free_ns(struct integrity_namespace *ns)
 {
+	integrity_fs_free(ns);
 	kmem_cache_free(integrityns_cachep, ns);
 }
 
-- 
2.31.1

