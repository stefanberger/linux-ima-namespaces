From 80bd5090c0de937977ff2a715d722012e3b55135 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Fri, 7 Jan 2022 15:13:31 -0500
Subject: [PATCH 46/57] ima: Adapt ima_reset_appraise_flags() for IMA
 namespacing support

The current implementation of ima_reset_appraise_flags() only properly
supports IMA appraisal by the init_ima_ns. To prepare for IMA appraisal
support for IMA namespaces modify the implementation to support IMA
appraisal used by any IMA namespace. In particular, set the
IMA_CHANGE_XATTR bit if any IMA namespace has an IMA appraisal policy.
Similarly, set or clear the IMA_DIGSIG flag if any IMA namespace has an
IMA appraisal policy.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 security/integrity/ima/ima_appraise.c | 34 +++++++++++++++++----------
 1 file changed, 21 insertions(+), 13 deletions(-)

diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index 8571c5461ed9..72e8a8af4081 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -615,13 +615,13 @@ static int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,
 	return 0;
 }
 
-static void ima_reset_appraise_flags(struct ima_namespace *ns,
-				     struct inode *inode, int digsig)
+static void ima_reset_appraise_flags(struct inode *inode, int digsig)
 {
 	struct integrity_iint_cache *iint;
 	struct ns_status *ns_status;
+	bool found = false;
 
-	if (!(ns->ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))
+	if (!S_ISREG(inode->i_mode))
 		return;
 
 	iint = integrity_iint_find(inode);
@@ -629,15 +629,22 @@ static void ima_reset_appraise_flags(struct ima_namespace *ns,
 		return;
 
 	read_lock(&iint->ns_list_lock);
-	list_for_each_entry(ns_status, &iint->ns_list, ns_next)
+	list_for_each_entry(ns_status, &iint->ns_list, ns_next) {
+		if (!(ns_status->ns->ima_policy_flag & IMA_APPRAISE))
+			continue;
+
 		ns_status->measured_pcrs = 0;
+		found = true;
+	}
 	read_unlock(&iint->ns_list_lock);
 
-	set_bit(IMA_CHANGE_XATTR, &iint->atomic_flags);
-	if (digsig)
-		set_bit(IMA_DIGSIG, &iint->atomic_flags);
-	else
-		clear_bit(IMA_DIGSIG, &iint->atomic_flags);
+	if (found) {
+		set_bit(IMA_CHANGE_XATTR, &iint->atomic_flags);
+		if (digsig)
+			set_bit(IMA_DIGSIG, &iint->atomic_flags);
+		else
+			clear_bit(IMA_DIGSIG, &iint->atomic_flags);
+	}
 }
 
 /**
@@ -706,7 +713,7 @@ int ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,
 		       const void *xattr_value, size_t xattr_value_len)
 {
 	const struct evm_ima_xattr_data *xvalue = xattr_value;
-	struct ima_namespace *ns = &init_ima_ns;
+	struct ima_namespace *ns = get_current_ns();
 	int digsig = 0;
 	int result;
 
@@ -720,24 +727,25 @@ int ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,
 		digsig = (xvalue->type == EVM_XATTR_PORTABLE_DIGSIG);
 	}
 	if (result == 1 || evm_revalidate_status(xattr_name)) {
+		if (!ns_is_active(ns))
+			return -EPERM;
 		result = validate_hash_algo(ns, dentry,
 					    xvalue, xattr_value_len);
 		if (result)
 			return result;
 
-		ima_reset_appraise_flags(ns, d_backing_inode(dentry), digsig);
+		ima_reset_appraise_flags(d_backing_inode(dentry), digsig);
 	}
 	return result;
 }
 
 int ima_inode_removexattr(struct dentry *dentry, const char *xattr_name)
 {
-	struct ima_namespace *ns = &init_ima_ns;
 	int result;
 
 	result = ima_protect_xattr(dentry, xattr_name, NULL, 0);
 	if (result == 1 || evm_revalidate_status(xattr_name)) {
-		ima_reset_appraise_flags(ns, d_backing_inode(dentry), 0);
+		ima_reset_appraise_flags(d_backing_inode(dentry), 0);
 		if (result == 1)
 			result = 0;
 	}
-- 
2.31.1

