From 0401ecda2702ef8eda62c8fd80a230e8f1ed838b Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Tue, 25 Apr 2023 10:44:48 -0400
Subject: [PATCH 02/90] tpm: Introduce concept of ownership of tpm_chip by
 user_namespace

Introduce the concept of ownership of a tpm_chip by a user_namespace
so that callers of tpm_default_chip() never get a chip that is
associted / in use by a different user namespace than the one querying
for te device.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 drivers/char/tpm/tpm-chip.c               | 72 +++++++++++++++++++++--
 drivers/char/tpm/tpm-interface.c          | 10 ++--
 drivers/char/tpm/tpm.h                    |  3 +-
 include/linux/tpm.h                       | 14 ++++-
 security/integrity/ima/ima_init.c         |  2 +-
 security/keys/trusted-keys/trusted_tpm1.c |  6 +-
 6 files changed, 90 insertions(+), 17 deletions(-)

diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c
index cd48033b804a..8c5745fcf449 100644
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -164,6 +164,8 @@ int tpm_try_get_ops(struct tpm_chip *chip)
 	if (rc)
 		goto out_lock;
 
+	chip->users++;
+
 	return 0;
 out_lock:
 	mutex_unlock(&chip->tpm_mutex);
@@ -183,6 +185,7 @@ EXPORT_SYMBOL_GPL(tpm_try_get_ops);
  */
 void tpm_put_ops(struct tpm_chip *chip)
 {
+	chip->users--;
 	tpm_chip_stop(chip);
 	mutex_unlock(&chip->tpm_mutex);
 	up_read(&chip->ops_sem);
@@ -190,10 +193,54 @@ void tpm_put_ops(struct tpm_chip *chip)
 }
 EXPORT_SYMBOL_GPL(tpm_put_ops);
 
+/**
+ * tpm_transfer_chip_user_ns() - transfer an unused chip to a user namespace
+ * @chip:      a &struct tpm_chip instance, %NULL for the default chip
+ * @user_ns:    the user namespace to transfer the unused chip to
+ *
+ * A chip can only be transferred to user_ns if it has no users.
+ */
+struct user_namespace *tpm_transfer_chip_user_ns(struct tpm_chip *chip,
+						 struct user_namespace *user_ns)
+{
+	struct user_namespace *ret;
+
+	mutex_lock(&chip->tpm_mutex);
+	ret = chip->user_ns;
+	if (chip->users == 0) {
+		ret = chip->user_ns = user_ns;
+		chip->users++;
+	}
+	mutex_unlock(&chip->tpm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tpm_transfer_chip_user_ns);
+
+/**
+ * tpm_release_chip_user_ns() - release a chip used by a user namespace
+ * @chip:      a &struct tpm_chip instance, %NULL for the default chip
+ */
+bool tpm_release_chip_user_ns(struct tpm_chip *chip)
+{
+	bool ret;
+
+	mutex_lock(&chip->tpm_mutex);
+	chip->users--;
+	ret = chip->users == 0;
+	if (ret)
+		chip->user_ns = NULL;
+	mutex_unlock(&chip->tpm_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tpm_release_chip_user_ns);
+
 /**
  * tpm_default_chip() - find a TPM chip and get a reference to it
+ * @user_ns:    the user namespace to transfer the unused chip to
  */
-struct tpm_chip *tpm_default_chip(void)
+struct tpm_chip *tpm_default_chip(struct user_namespace *user_ns)
 {
 	struct tpm_chip *chip, *res = NULL;
 	int chip_num = 0;
@@ -204,7 +251,8 @@ struct tpm_chip *tpm_default_chip(void)
 	do {
 		chip_prev = chip_num;
 		chip = idr_get_next(&dev_nums_idr, &chip_num);
-		if (chip) {
+		if (chip &&
+		    tpm_transfer_chip_user_ns(chip, user_ns) == user_ns) {
 			get_device(&chip->dev);
 			res = chip;
 			break;
@@ -217,9 +265,22 @@ struct tpm_chip *tpm_default_chip(void)
 }
 EXPORT_SYMBOL_GPL(tpm_default_chip);
 
+/**
+ * tpm_put_default_chip() - release chip found using tpm_default_chip()
+ * @chip:      a &struct tpm_chip instance
+ */
+void tpm_put_default_chip(struct tpm_chip *chip)
+{
+	BUG_ON(!tpm_release_chip_user_ns(chip));
+
+	put_device(&chip->dev);
+}
+EXPORT_SYMBOL_GPL(tpm_put_default_chip);
+
 /**
  * tpm_find_get_ops() - find and reserve a TPM chip
  * @chip:	a &struct tpm_chip instance, %NULL for the default chip
+ * @user_ns:    The user namespace requesting the use of the chip
  *
  * Finds a TPM chip and reserves its class device and operations. The chip must
  * be released with tpm_put_ops() after use.
@@ -232,7 +293,8 @@ EXPORT_SYMBOL_GPL(tpm_default_chip);
  * %NULL if a chip is not found.
  * %NULL if the chip is not available.
  */
-struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip)
+struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip,
+				  struct user_namespace *user_ns)
 {
 	int rc;
 
@@ -242,12 +304,12 @@ struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip)
 		return NULL;
 	}
 
-	chip = tpm_default_chip();
+	chip = tpm_default_chip(user_ns);
 	if (!chip)
 		return NULL;
 	rc = tpm_try_get_ops(chip);
 	/* release additional reference we got from tpm_default_chip() */
-	put_device(&chip->dev);
+	tpm_put_default_chip(chip);
 	if (rc)
 		return NULL;
 	return chip;
diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c
index 586ca10b0d72..cf39fae1a338 100644
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@ -261,7 +261,7 @@ int tpm_is_tpm2(struct tpm_chip *chip)
 {
 	int rc;
 
-	chip = tpm_find_get_ops(chip);
+	chip = tpm_find_get_ops(chip, current_user_ns());
 	if (!chip)
 		return -ENODEV;
 
@@ -286,7 +286,7 @@ int tpm_pcr_read(struct tpm_chip *chip, u32 pcr_idx,
 {
 	int rc;
 
-	chip = tpm_find_get_ops(chip);
+	chip = tpm_find_get_ops(chip, current_user_ns());
 	if (!chip)
 		return -ENODEV;
 
@@ -317,7 +317,7 @@ int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
 	int rc;
 	int i;
 
-	chip = tpm_find_get_ops(chip);
+	chip = tpm_find_get_ops(chip, current_user_ns());
 	if (!chip)
 		return -ENODEV;
 
@@ -355,7 +355,7 @@ int tpm_send(struct tpm_chip *chip, void *cmd, size_t buflen)
 	struct tpm_buf buf;
 	int rc;
 
-	chip = tpm_find_get_ops(chip);
+	chip = tpm_find_get_ops(chip, current_user_ns());
 	if (!chip)
 		return -ENODEV;
 
@@ -458,7 +458,7 @@ int tpm_get_random(struct tpm_chip *chip, u8 *out, size_t max)
 	if (!out || max > TPM_MAX_RNG_DATA)
 		return -EINVAL;
 
-	chip = tpm_find_get_ops(chip);
+	chip = tpm_find_get_ops(chip, current_user_ns());
 	if (!chip)
 		return -ENODEV;
 
diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h
index 460bb85dd142..360fc7112791 100644
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@ -267,7 +267,8 @@ static inline void tpm_msleep(unsigned int delay_msec)
 int tpm_chip_bootstrap(struct tpm_chip *chip);
 int tpm_chip_start(struct tpm_chip *chip);
 void tpm_chip_stop(struct tpm_chip *chip);
-struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip);
+struct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip,
+				  struct user_namespace *user_ns);
 
 struct tpm_chip *tpm_chip_alloc(struct device *dev,
 				const struct tpm_class_ops *ops);
diff --git a/include/linux/tpm.h b/include/linux/tpm.h
index 6a1e8f157255..fd5f1298ed7b 100644
--- a/include/linux/tpm.h
+++ b/include/linux/tpm.h
@@ -30,6 +30,7 @@
 struct tpm_chip;
 struct trusted_key_payload;
 struct trusted_key_options;
+struct user_namespace;
 
 /* if you add a new hash to this, increment TPM_MAX_HASHES below */
 enum tpm_algorithms {
@@ -170,6 +171,11 @@ struct tpm_chip {
 
 	/* active locality */
 	int locality;
+
+	/* user namespace TPM chip is associated with / used by */
+	struct user_namespace *user_ns;
+	/* count of uses by above user_ns */
+	int users;
 };
 
 #define TPM_HEADER_SIZE		10
@@ -430,7 +436,11 @@ extern int tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,
 			  struct tpm_digest *digests);
 extern int tpm_send(struct tpm_chip *chip, void *cmd, size_t buflen);
 extern int tpm_get_random(struct tpm_chip *chip, u8 *data, size_t max);
-extern struct tpm_chip *tpm_default_chip(void);
+extern struct user_namespace *tpm_transfer_chip_user_ns(struct tpm_chip *chip,
+					       struct user_namespace *user_ns);
+extern bool tpm_release_chip_user_ns(struct tpm_chip *chip);
+extern struct tpm_chip *tpm_default_chip(struct user_namespace *user_ns);
+extern void tpm_put_default_chip(struct tpm_chip *chip);
 void tpm2_flush_context(struct tpm_chip *chip, u32 handle);
 #else
 static inline int tpm_is_tpm2(struct tpm_chip *chip)
@@ -458,7 +468,7 @@ static inline int tpm_get_random(struct tpm_chip *chip, u8 *data, size_t max)
 	return -ENODEV;
 }
 
-static inline struct tpm_chip *tpm_default_chip(void)
+static inline struct tpm_chip *tpm_default_chip(struct user_namespace *user_ns)
 {
 	return NULL;
 }
diff --git a/security/integrity/ima/ima_init.c b/security/integrity/ima/ima_init.c
index da2a37ff431d..f929da47ddaa 100644
--- a/security/integrity/ima/ima_init.c
+++ b/security/integrity/ima/ima_init.c
@@ -121,7 +121,7 @@ int __init ima_init(void)
 	if (rc)
 		return rc;
 
-	ima_tpm_chip = tpm_default_chip();
+	ima_tpm_chip = tpm_default_chip(&init_user_ns);
 	if (!ima_tpm_chip)
 		pr_info("No TPM chip found, activating TPM-bypass!\n");
 
diff --git a/security/keys/trusted-keys/trusted_tpm1.c b/security/keys/trusted-keys/trusted_tpm1.c
index aa108bea6739..f5d6974f41a3 100644
--- a/security/keys/trusted-keys/trusted_tpm1.c
+++ b/security/keys/trusted-keys/trusted_tpm1.c
@@ -1031,7 +1031,7 @@ static int __init trusted_tpm_init(void)
 {
 	int ret;
 
-	chip = tpm_default_chip();
+	chip = tpm_default_chip(current_user_ns());
 	if (!chip)
 		return -ENODEV;
 
@@ -1050,14 +1050,14 @@ static int __init trusted_tpm_init(void)
 err_free:
 	kfree(digests);
 err_put:
-	put_device(&chip->dev);
+	tpm_put_default_chip(chip);
 	return ret;
 }
 
 static void trusted_tpm_exit(void)
 {
 	if (chip) {
-		put_device(&chip->dev);
+		tpm_put_default_chip(chip);
 		kfree(digests);
 		trusted_shash_release();
 		unregister_key_type(&key_type_trusted);
-- 
2.40.1

