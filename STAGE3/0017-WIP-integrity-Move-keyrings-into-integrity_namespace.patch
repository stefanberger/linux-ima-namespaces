From f2a773e3c2b9e07a2a7964b018c2739498252071 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Sat, 1 Jan 2022 19:08:06 -0500
Subject: [PATCH 17/20] WIP: integrity: Move keyrings into integrity_namespace

Define an integrity_namespace structure and move the keyrings into it.
Also define an init_integrity_ns that holds the hosts keyrings.

Reference the init_integrity_ns from the init_ima_ns.

Pass a pointer to the integrity_namespace structure through the APIs
so that the keyrings can be accessed through this sructure now.

Define current_integrity_ns() for configurations when CONFIG_IMA_NS is
defined or when only CONFIG_IMA is defined or when neither one of them
is defined.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 include/linux/evm.h                           | 14 ++--
 include/linux/ima.h                           |  1 +
 include/linux/integrity_namespace.h           | 52 ++++++++++++++
 security/integrity/Makefile                   |  3 +-
 security/integrity/digsig.c                   | 70 +++++++++++--------
 security/integrity/evm/evm_main.c             | 37 ++++++----
 security/integrity/ima/ima.h                  |  6 +-
 security/integrity/ima/ima_appraise.c         | 30 +++++---
 security/integrity/ima/ima_init.c             |  3 +-
 security/integrity/ima/ima_init_ima_ns.c      |  7 ++
 security/integrity/ima/ima_main.c             |  2 +-
 security/integrity/ima/ima_ns.c               |  1 +
 security/integrity/integrity.h                | 35 ++++++----
 security/integrity/integrity_ns.c             | 40 +++++++++++
 .../platform_certs/platform_keyring.c         |  9 ++-
 15 files changed, 226 insertions(+), 84 deletions(-)
 create mode 100644 security/integrity/integrity_ns.c

diff --git a/include/linux/evm.h b/include/linux/evm.h
index 4c374be70247..ef7a6b70e124 100644
--- a/include/linux/evm.h
+++ b/include/linux/evm.h
@@ -13,10 +13,12 @@
 #include <linux/xattr.h>
 
 struct integrity_iint_cache;
+struct integrity_namespace;
 
 #ifdef CONFIG_EVM
 extern int evm_set_key(void *key, size_t keylen);
-extern enum integrity_status evm_verifyxattr(struct dentry *dentry,
+extern enum integrity_status evm_verifyxattr(struct integrity_namespace *ns,
+					     struct dentry *dentry,
 					     const char *xattr_name,
 					     void *xattr_value,
 					     size_t xattr_value_len,
@@ -58,10 +60,12 @@ static inline int evm_set_key(void *key, size_t keylen)
 }
 
 #ifdef CONFIG_INTEGRITY
-static inline enum integrity_status evm_verifyxattr(struct dentry *dentry,
-						    const char *xattr_name,
-						    void *xattr_value,
-						    size_t xattr_value_len,
+static inline enum integrity_status evm_verifyxattr(
+					struct integrity_namespace *ns,
+					struct dentry *dentry,
+					const char *xattr_name,
+					void *xattr_value,
+					size_t xattr_value_len,
 					struct integrity_iint_cache *iint)
 {
 	return INTEGRITY_UNKNOWN;
diff --git a/include/linux/ima.h b/include/linux/ima.h
index b12ed00e8944..d76ec712e78b 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -12,6 +12,7 @@
 #include <linux/security.h>
 #include <linux/kexec.h>
 #include <linux/user_namespace.h>
+#include <linux/integrity.h>
 #include <crypto/hash_info.h>
 struct linux_binprm;
 
diff --git a/include/linux/integrity_namespace.h b/include/linux/integrity_namespace.h
index 2eb5ee2cfd30..60cdad4f1349 100644
--- a/include/linux/integrity_namespace.h
+++ b/include/linux/integrity_namespace.h
@@ -7,6 +7,23 @@
 #ifndef _LINUX_INTEGRITY_NAMESPACE_H
 #define _LINUX_INTEGRITY_NAMESPACE_H
 
+#include <linux/cred.h>
+#include <linux/user_namespace.h>
+
+#define INTEGRITY_KEYRING_EVM		0
+#define INTEGRITY_KEYRING_IMA		1
+#define INTEGRITY_KEYRING_PLATFORM	2
+#define INTEGRITY_KEYRING_MAX		3
+
+struct integrity_namespace {
+	struct key *keyring[INTEGRITY_KEYRING_MAX];
+};
+extern struct integrity_namespace init_integrity_ns;
+
+struct integrity_namespace *integrity_create_ns(void);
+void integrity_free_ns(struct integrity_namespace *ns);
+
+
 #if CONFIG_IMA
 
 #define IMA_HASH_BITS 10
@@ -63,9 +80,44 @@ struct ima_namespace {
 
 	struct crypto_shash *ima_shash_tfm;
 	struct crypto_ahash *ima_ahash_tfm;
+
+	struct integrity_namespace *integrity_ns;
 } __randomize_layout;
 extern struct ima_namespace init_ima_ns;
 
 #endif /* CONFIG_IMA */
 
+#if CONFIG_IMA
+
+#if CONFIG_IMA_NS
+
+static inline struct ima_namespace *current_ima_ns(void)
+{
+	return current_user_ns()->ima_ns;
+}
+
+#else
+
+static inline struct ima_namespace *current_ima_ns(void)
+{
+	return &init_ima_ns;
+}
+
+#endif /* CONFIG_IMA_NS */
+
+static inline struct integrity_namespace *current_integrity_ns(void)
+{
+	struct ima_namespace *ns = current_ima_ns();
+	return ns->integrity_ns;
+}
+
+#else
+
+static inline struct integrity_namespace *current_integrity_ns(void)
+{
+	struct &init_integrity_ns;
+}
+
+#endif /* CONFIG_IMA_NS */
+
 #endif /* _LINUX_INTEGRITY_NAMESPACE_H */
diff --git a/security/integrity/Makefile b/security/integrity/Makefile
index 7ee39d66cf16..33bcdda45ec3 100644
--- a/security/integrity/Makefile
+++ b/security/integrity/Makefile
@@ -7,7 +7,8 @@ obj-$(CONFIG_INTEGRITY) += integrity.o
 
 integrity-y := iint.o
 integrity-$(CONFIG_INTEGRITY_AUDIT) += integrity_audit.o
-integrity-$(CONFIG_INTEGRITY_SIGNATURE) += digsig.o
+integrity-$(CONFIG_INTEGRITY_SIGNATURE) += digsig.o \
+					   integrity_ns.o
 integrity-$(CONFIG_INTEGRITY_ASYMMETRIC_KEYS) += digsig_asymmetric.o
 integrity-$(CONFIG_INTEGRITY_PLATFORM_KEYRING) += platform_certs/platform_keyring.o
 integrity-$(CONFIG_LOAD_UEFI_KEYS) += platform_certs/efi_parser.o \
diff --git a/security/integrity/digsig.c b/security/integrity/digsig.c
index 3b06a01bd0fd..89ddf5218766 100644
--- a/security/integrity/digsig.c
+++ b/security/integrity/digsig.c
@@ -14,13 +14,12 @@
 #include <linux/key-type.h>
 #include <linux/digsig.h>
 #include <linux/vmalloc.h>
+#include <linux/integrity_namespace.h>
 #include <crypto/public_key.h>
 #include <keys/system_keyring.h>
 
 #include "integrity.h"
 
-static struct key *keyring[INTEGRITY_KEYRING_MAX];
-
 static const char * const keyring_name[INTEGRITY_KEYRING_MAX] = {
 #ifndef CONFIG_INTEGRITY_TRUSTED_KEYRING
 	"_evm",
@@ -38,26 +37,28 @@ static const char * const keyring_name[INTEGRITY_KEYRING_MAX] = {
 #define restrict_link_to_ima restrict_link_by_builtin_trusted
 #endif
 
-static struct key *integrity_keyring_from_id(const unsigned int id)
+static struct key *integrity_keyring_from_id(struct integrity_namespace *ns,
+					     const unsigned int id)
 {
 	if (id >= INTEGRITY_KEYRING_MAX)
 		return ERR_PTR(-EINVAL);
 
-	if (!keyring[id]) {
-		keyring[id] =
+	if (!ns->keyring[id]) {
+		ns->keyring[id] =
 			request_key(&key_type_keyring, keyring_name[id], NULL);
-		if (IS_ERR(keyring[id])) {
-			int err = PTR_ERR(keyring[id]);
+		if (IS_ERR(ns->keyring[id])) {
+			int err = PTR_ERR(ns->keyring[id]);
 			pr_err("no %s keyring: %d\n", keyring_name[id], err);
-			keyring[id] = NULL;
+			ns->keyring[id] = NULL;
 			return ERR_PTR(err);
 		}
 	}
 
-	return keyring[id];
+	return ns->keyring[id];
 }
 
-int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,
+int integrity_digsig_verify(struct integrity_namespace *ns,
+			    const unsigned int id, const char *sig, int siglen,
 			    const char *digest, int digestlen)
 {
 	struct key *keyring;
@@ -65,7 +66,7 @@ int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,
 	if (siglen < 2)
 		return -EINVAL;
 
-	keyring = integrity_keyring_from_id(id);
+	keyring = integrity_keyring_from_id(ns, id);
 	if (IS_ERR(keyring))
 		return PTR_ERR(keyring);
 
@@ -82,43 +83,46 @@ int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,
 	return -EOPNOTSUPP;
 }
 
-int integrity_modsig_verify(const unsigned int id, const struct modsig *modsig)
+int integrity_modsig_verify(struct integrity_namespace *ns,
+			    const unsigned int id, const struct modsig *modsig)
 {
 	struct key *keyring;
 
-	keyring = integrity_keyring_from_id(id);
+	keyring = integrity_keyring_from_id(ns, id);
 	if (IS_ERR(keyring))
 		return PTR_ERR(keyring);
 
 	return ima_modsig_verify(keyring, modsig);
 }
 
-static int __init __integrity_init_keyring(const unsigned int id,
+static int __init __integrity_init_keyring(struct integrity_namespace *ns,
+					   const unsigned int id,
 					   key_perm_t perm,
 					   struct key_restriction *restriction)
 {
 	const struct cred *cred = current_cred();
 	int err = 0;
 
-	keyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),
-				    KGIDT_INIT(0), cred, perm,
-				    KEY_ALLOC_NOT_IN_QUOTA, restriction, NULL);
-	if (IS_ERR(keyring[id])) {
-		err = PTR_ERR(keyring[id]);
+	ns->keyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),
+					KGIDT_INIT(0), cred, perm,
+					KEY_ALLOC_NOT_IN_QUOTA, restriction, NULL);
+	if (IS_ERR(ns->keyring[id])) {
+		err = PTR_ERR(ns->keyring[id]);
 		pr_info("Can't allocate %s keyring (%d)\n",
 			keyring_name[id], err);
-		keyring[id] = NULL;
+		ns->keyring[id] = NULL;
 	} else {
 		if (id == INTEGRITY_KEYRING_PLATFORM)
-			set_platform_trusted_keys(keyring[id]);
+			set_platform_trusted_keys(ns->keyring[id]);
 		if (id == INTEGRITY_KEYRING_IMA)
-			load_module_cert(keyring[id]);
+			load_module_cert(ns->keyring[id]);
 	}
 
 	return err;
 }
 
-int __init integrity_init_keyring(const unsigned int id)
+int __init integrity_init_keyring(struct integrity_namespace *ns,
+				  const unsigned int id)
 {
 	struct key_restriction *restriction;
 	key_perm_t perm;
@@ -142,19 +146,21 @@ int __init integrity_init_keyring(const unsigned int id)
 	perm |= KEY_USR_WRITE;
 
 out:
-	return __integrity_init_keyring(id, perm, restriction);
+	return __integrity_init_keyring(ns, id, perm, restriction);
 }
 
-static int __init integrity_add_key(const unsigned int id, const void *data,
+static int __init integrity_add_key(struct integrity_namespace *ns,
+				    const unsigned int id, const void *data,
 				    off_t size, key_perm_t perm)
 {
 	key_ref_t key;
 	int rc = 0;
 
-	if (!keyring[id])
+	if (!ns->keyring[id])
 		return -EINVAL;
 
-	key = key_create_or_update(make_key_ref(keyring[id], 1), "asymmetric",
+	key = key_create_or_update(make_key_ref(ns->keyring[id], 1),
+				   "asymmetric",
 				   NULL, data, size, perm,
 				   KEY_ALLOC_NOT_IN_QUOTA);
 	if (IS_ERR(key)) {
@@ -170,7 +176,8 @@ static int __init integrity_add_key(const unsigned int id, const void *data,
 
 }
 
-int __init integrity_load_x509(const unsigned int id, const char *path)
+int __init integrity_load_x509(struct integrity_namespace *ns,
+			       const unsigned int id, const char *path)
 {
 	void *data = NULL;
 	size_t size;
@@ -188,18 +195,19 @@ int __init integrity_load_x509(const unsigned int id, const char *path)
 	perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW | KEY_USR_READ;
 
 	pr_info("Loading X.509 certificate: %s\n", path);
-	rc = integrity_add_key(id, (const void *)data, size, perm);
+	rc = integrity_add_key(ns, id, (const void *)data, size, perm);
 
 	vfree(data);
 	return rc;
 }
 
-int __init integrity_load_cert(const unsigned int id, const char *source,
+int __init integrity_load_cert(struct integrity_namespace *ns,
+			       const unsigned int id, const char *source,
 			       const void *data, size_t len, key_perm_t perm)
 {
 	if (!data)
 		return -EINVAL;
 
 	pr_info("Loading X.509 certificate: %s\n", source);
-	return integrity_add_key(id, data, len, perm);
+	return integrity_add_key(ns, id, data, len, perm);
 }
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index 08f907382c61..951c1971f70e 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -21,6 +21,7 @@
 #include <linux/evm.h>
 #include <linux/magic.h>
 #include <linux/posix_acl_xattr.h>
+#include <linux/integrity_namespace.h>
 
 #include <crypto/hash.h>
 #include <crypto/hash_info.h>
@@ -170,7 +171,8 @@ static int evm_find_protected_xattrs(struct dentry *dentry)
  *
  * Returns integrity status
  */
-static enum integrity_status evm_verify_hmac(struct dentry *dentry,
+static enum integrity_status evm_verify_hmac(struct integrity_namespace *ns,
+					     struct dentry *dentry,
 					     const char *xattr_name,
 					     char *xattr_value,
 					     size_t xattr_value_len,
@@ -242,7 +244,7 @@ static enum integrity_status evm_verify_hmac(struct dentry *dentry,
 				   xattr_value_len, xattr_data->type, &digest);
 		if (rc)
 			break;
-		rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
+		rc = integrity_digsig_verify(ns, INTEGRITY_KEYRING_EVM,
 					(const char *)xattr_data, xattr_len,
 					digest.digest, digest.hdr.length);
 		if (!rc) {
@@ -406,7 +408,8 @@ int evm_read_protected_xattrs(struct dentry *dentry, u8 *buffer,
  * This function requires the caller to lock the inode's i_mutex before it
  * is executed.
  */
-enum integrity_status evm_verifyxattr(struct dentry *dentry,
+enum integrity_status evm_verifyxattr(struct integrity_namespace *ns,
+				      struct dentry *dentry,
 				      const char *xattr_name,
 				      void *xattr_value, size_t xattr_value_len,
 				      struct integrity_iint_cache *iint)
@@ -419,7 +422,7 @@ enum integrity_status evm_verifyxattr(struct dentry *dentry,
 		if (!iint)
 			return INTEGRITY_UNKNOWN;
 	}
-	return evm_verify_hmac(dentry, xattr_name, xattr_value,
+	return evm_verify_hmac(ns, dentry, xattr_name, xattr_value,
 				 xattr_value_len, iint);
 }
 EXPORT_SYMBOL_GPL(evm_verifyxattr);
@@ -431,13 +434,14 @@ EXPORT_SYMBOL_GPL(evm_verifyxattr);
  * Verify and return the dentry's metadata integrity. The exceptions are
  * before EVM is initialized or in 'fix' mode.
  */
-static enum integrity_status evm_verify_current_integrity(struct dentry *dentry)
+static enum integrity_status evm_verify_current_integrity(
+			struct integrity_namespace *ns, struct dentry *dentry)
 {
 	struct inode *inode = d_backing_inode(dentry);
 
 	if (!evm_key_loaded() || !S_ISREG(inode->i_mode) || evm_fixmode)
 		return 0;
-	return evm_verify_hmac(dentry, NULL, NULL, 0, NULL);
+	return evm_verify_hmac(ns, dentry, NULL, NULL, 0, NULL);
 }
 
 /*
@@ -538,7 +542,8 @@ static int evm_xattr_change(struct user_namespace *mnt_userns,
  * For posix xattr acls only, permit security.evm, even if it currently
  * doesn't exist, to be updated unless the EVM signature is immutable.
  */
-static int evm_protect_xattr(struct user_namespace *mnt_userns,
+static int evm_protect_xattr(struct integrity_namespace *ns,
+			     struct user_namespace *mnt_userns,
 			     struct dentry *dentry, const char *xattr_name,
 			     const void *xattr_value, size_t xattr_value_len)
 {
@@ -550,14 +555,14 @@ static int evm_protect_xattr(struct user_namespace *mnt_userns,
 	} else if (!evm_protected_xattr(xattr_name)) {
 		if (!posix_xattr_acl(xattr_name))
 			return 0;
-		evm_status = evm_verify_current_integrity(dentry);
+		evm_status = evm_verify_current_integrity(ns, dentry);
 		if ((evm_status == INTEGRITY_PASS) ||
 		    (evm_status == INTEGRITY_NOXATTRS))
 			return 0;
 		goto out;
 	}
 
-	evm_status = evm_verify_current_integrity(dentry);
+	evm_status = evm_verify_current_integrity(ns, dentry);
 	if (evm_status == INTEGRITY_NOXATTRS) {
 		struct integrity_iint_cache *iint;
 
@@ -626,6 +631,7 @@ int evm_inode_setxattr(struct user_namespace *mnt_userns, struct dentry *dentry,
 		       size_t xattr_value_len)
 {
 	const struct evm_ima_xattr_data *xattr_data = xattr_value;
+	struct integrity_namespace *ns = current_integrity_ns();
 
 	/* Policy permits modification of the protected xattrs even though
 	 * there's no HMAC key loaded
@@ -640,8 +646,8 @@ int evm_inode_setxattr(struct user_namespace *mnt_userns, struct dentry *dentry,
 		    xattr_data->type != EVM_XATTR_PORTABLE_DIGSIG)
 			return -EPERM;
 	}
-	return evm_protect_xattr(mnt_userns, dentry, xattr_name, xattr_value,
-				 xattr_value_len);
+	return evm_protect_xattr(ns, mnt_userns, dentry, xattr_name,
+				 xattr_value, xattr_value_len);
 }
 
 /**
@@ -656,13 +662,14 @@ int evm_inode_setxattr(struct user_namespace *mnt_userns, struct dentry *dentry,
 int evm_inode_removexattr(struct user_namespace *mnt_userns,
 			  struct dentry *dentry, const char *xattr_name)
 {
+	struct integrity_namespace *ns = current_integrity_ns();
 	/* Policy permits modification of the protected xattrs even though
 	 * there's no HMAC key loaded
 	 */
 	if (evm_initialized & EVM_ALLOW_METADATA_WRITES)
 		return 0;
 
-	return evm_protect_xattr(mnt_userns, dentry, xattr_name, NULL, 0);
+	return evm_protect_xattr(ns, mnt_userns, dentry, xattr_name, NULL, 0);
 }
 
 static void evm_reset_status(struct inode *inode)
@@ -779,6 +786,7 @@ int evm_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	unsigned int ia_valid = attr->ia_valid;
 	enum integrity_status evm_status;
+	struct integrity_namespace *ns = current_integrity_ns();
 
 	/* Policy permits modification of the protected attrs even though
 	 * there's no HMAC key loaded
@@ -788,7 +796,7 @@ int evm_inode_setattr(struct dentry *dentry, struct iattr *attr)
 
 	if (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))
 		return 0;
-	evm_status = evm_verify_current_integrity(dentry);
+	evm_status = evm_verify_current_integrity(ns, dentry);
 	/*
 	 * Writing attrs is safe for portable signatures, as portable signatures
 	 * are immutable and can never be updated.
@@ -883,10 +891,11 @@ static int __init init_evm(void)
 {
 	int error;
 	struct list_head *pos, *q;
+	struct integrity_namespace *ns = &init_integrity_ns;
 
 	evm_init_config();
 
-	error = integrity_init_keyring(INTEGRITY_KEYRING_EVM);
+	error = integrity_init_keyring(ns, INTEGRITY_KEYRING_EVM);
 	if (error)
 		goto error;
 
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index d2c95e8e785d..ccd8fcf7b62b 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -336,7 +336,8 @@ int ima_policy_show(struct seq_file *m, void *v);
 int ima_check_blacklist(struct ima_namespace *ns,
 			struct integrity_iint_cache *iint,
 			const struct modsig *modsig, int pcr);
-int ima_appraise_measurement(enum ima_hooks func,
+int ima_appraise_measurement(struct ima_namespace *ns,
+			     enum ima_hooks func,
 			     struct integrity_iint_cache *iint,
 			     struct file *file, const unsigned char *filename,
 			     struct evm_ima_xattr_data *xattr_value,
@@ -361,7 +362,8 @@ static inline int ima_check_blacklist(struct ima_namespace *ns,
 	return 0;
 }
 
-static inline int ima_appraise_measurement(enum ima_hooks func,
+static inline int ima_appraise_measurement(struct ima_namespace *ns,
+					   enum ima_hooks func,
 					   struct integrity_iint_cache *iint,
 					   struct file *file,
 					   const unsigned char *filename,
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index 856fd1af8032..ca8a8e876186 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -233,7 +233,8 @@ int ima_read_xattr(struct dentry *dentry,
  *
  * Return 0 on success, error code otherwise.
  */
-static int xattr_verify(enum ima_hooks func, struct integrity_iint_cache *iint,
+static int xattr_verify(struct ima_namespace *ns,
+			enum ima_hooks func, struct integrity_iint_cache *iint,
 			struct evm_ima_xattr_data *xattr_value, int xattr_len,
 			enum integrity_status *status, const char **cause)
 {
@@ -275,7 +276,8 @@ static int xattr_verify(enum ima_hooks func, struct integrity_iint_cache *iint,
 		break;
 	case EVM_IMA_XATTR_DIGSIG:
 		set_bit(IMA_DIGSIG, &iint->atomic_flags);
-		rc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,
+		rc = integrity_digsig_verify(ns->integrity_ns,
+					     INTEGRITY_KEYRING_IMA,
 					     (const char *)xattr_value,
 					     xattr_len,
 					     iint->ima_hash->digest,
@@ -286,7 +288,8 @@ static int xattr_verify(enum ima_hooks func, struct integrity_iint_cache *iint,
 		}
 		if (IS_ENABLED(CONFIG_INTEGRITY_PLATFORM_KEYRING) && rc &&
 		    func == KEXEC_KERNEL_CHECK)
-			rc = integrity_digsig_verify(INTEGRITY_KEYRING_PLATFORM,
+			rc = integrity_digsig_verify(ns->integrity_ns,
+						     INTEGRITY_KEYRING_PLATFORM,
 						     (const char *)xattr_value,
 						     xattr_len,
 						     iint->ima_hash->digest,
@@ -314,15 +317,18 @@ static int xattr_verify(enum ima_hooks func, struct integrity_iint_cache *iint,
  *
  * Return 0 on success, error code otherwise.
  */
-static int modsig_verify(enum ima_hooks func, const struct modsig *modsig,
+static int modsig_verify(struct ima_namespace *ns,
+			 enum ima_hooks func, const struct modsig *modsig,
 			 enum integrity_status *status, const char **cause)
 {
 	int rc;
 
-	rc = integrity_modsig_verify(INTEGRITY_KEYRING_IMA, modsig);
+	rc = integrity_modsig_verify(ns->integrity_ns,
+				     INTEGRITY_KEYRING_IMA, modsig);
 	if (IS_ENABLED(CONFIG_INTEGRITY_PLATFORM_KEYRING) && rc &&
 	    func == KEXEC_KERNEL_CHECK)
-		rc = integrity_modsig_verify(INTEGRITY_KEYRING_PLATFORM,
+		rc = integrity_modsig_verify(ns->integrity_ns,
+					     INTEGRITY_KEYRING_PLATFORM,
 					     modsig);
 	if (rc) {
 		*cause = "invalid-signature";
@@ -376,7 +382,8 @@ int ima_check_blacklist(struct ima_namespace *ns,
  *
  * Return 0 on success, error code otherwise
  */
-int ima_appraise_measurement(enum ima_hooks func,
+int ima_appraise_measurement(struct ima_namespace *ns,
+			     enum ima_hooks func,
 			     struct integrity_iint_cache *iint,
 			     struct file *file, const unsigned char *filename,
 			     struct evm_ima_xattr_data *xattr_value,
@@ -411,7 +418,8 @@ int ima_appraise_measurement(enum ima_hooks func,
 		goto out;
 	}
 
-	status = evm_verifyxattr(dentry, XATTR_NAME_IMA, xattr_value, rc, iint);
+	status = evm_verifyxattr(ns->integrity_ns, dentry, XATTR_NAME_IMA,
+				 xattr_value, rc, iint);
 	switch (status) {
 	case INTEGRITY_PASS:
 	case INTEGRITY_PASS_IMMUTABLE:
@@ -437,8 +445,8 @@ int ima_appraise_measurement(enum ima_hooks func,
 	}
 
 	if (xattr_value)
-		rc = xattr_verify(func, iint, xattr_value, xattr_len, &status,
-				  &cause);
+		rc = xattr_verify(ns, func, iint, xattr_value, xattr_len,
+				  &status, &cause);
 
 	/*
 	 * If we have a modsig and either no imasig or the imasig's key isn't
@@ -447,7 +455,7 @@ int ima_appraise_measurement(enum ima_hooks func,
 	if (try_modsig &&
 	    (!xattr_value || xattr_value->type == IMA_XATTR_DIGEST_NG ||
 	     rc == -ENOKEY))
-		rc = modsig_verify(func, modsig, &status, &cause);
+		rc = modsig_verify(ns, func, modsig, &status, &cause);
 
 out:
 	/*
diff --git a/security/integrity/ima/ima_init.c b/security/integrity/ima/ima_init.c
index 3a7be12234ac..639bce8aa404 100644
--- a/security/integrity/ima/ima_init.c
+++ b/security/integrity/ima/ima_init.c
@@ -119,7 +119,8 @@ int __init ima_init(void)
 {
 	int rc;
 
-	rc = integrity_init_keyring(INTEGRITY_KEYRING_IMA);
+	rc = integrity_init_keyring(init_ima_ns.integrity_ns,
+				    INTEGRITY_KEYRING_IMA);
 	if (rc)
 		return rc;
 
diff --git a/security/integrity/ima/ima_init_ima_ns.c b/security/integrity/ima/ima_init_ima_ns.c
index 034351ec9d38..042ca16bacea 100644
--- a/security/integrity/ima/ima_init_ima_ns.c
+++ b/security/integrity/ima/ima_init_ima_ns.c
@@ -37,6 +37,12 @@ int ima_init_namespace(struct ima_namespace *ns)
 	ns->valid_policy = 1;
 	ns->ima_fs_flags = 0;
 
+	if (ns != &init_ima_ns) {
+		ns->integrity_ns = integrity_create_ns();
+		if (IS_ERR(ns->integrity_ns))
+			return PTR_ERR(ns->integrity_ns);
+	}
+
 	if (ns == &init_ima_ns) {
 		ns->ima_tpm_chip = tpm_default_chip();
 		if (ns->ima_tpm_chip)
@@ -83,5 +89,6 @@ int __init ima_ns_init(void)
 }
 
 struct ima_namespace init_ima_ns = {
+	.integrity_ns = &init_integrity_ns,
 };
 EXPORT_SYMBOL(init_ima_ns);
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 8b3886fcd3e4..bdd8b2cdcadc 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -396,7 +396,7 @@ static int __process_measurement(struct ima_namespace *ns,
 		rc = ima_check_blacklist(ns, iint, modsig, pcr);
 		if (rc != -EPERM) {
 			inode_lock(inode);
-			rc = ima_appraise_measurement(func, iint, file,
+			rc = ima_appraise_measurement(ns, func, iint, file,
 						      pathname, xattr_value,
 						      xattr_len, modsig);
 			inode_unlock(inode);
diff --git a/security/integrity/ima/ima_ns.c b/security/integrity/ima/ima_ns.c
index 6728ef0bbc63..3ef8fad72bff 100644
--- a/security/integrity/ima/ima_ns.c
+++ b/security/integrity/ima/ima_ns.c
@@ -40,6 +40,7 @@ struct ima_namespace *create_ima_ns(struct user_namespace *user_ns)
 static void destroy_ima_ns(struct ima_namespace *ns)
 {
 	pr_debug("DESTROY ima_ns: %p\n", ns);
+	integrity_free_ns(ns->integrity_ns);
 	ima_free_digests(ns);
 	ima_deinit_crypto(ns);
 	ima_free_policy_rules(ns);
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index 4941bee50fe6..3202d3079df7 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -151,46 +151,51 @@ struct integrity_iint_cache *integrity_iint_find(struct inode *inode);
 int integrity_kernel_read(struct file *file, loff_t offset,
 			  void *addr, unsigned long count);
 
-#define INTEGRITY_KEYRING_EVM		0
-#define INTEGRITY_KEYRING_IMA		1
-#define INTEGRITY_KEYRING_PLATFORM	2
-#define INTEGRITY_KEYRING_MAX		3
-
 extern struct dentry *integrity_dir;
 
 struct modsig;
+struct integrity_namespace;
 
 #ifdef CONFIG_INTEGRITY_SIGNATURE
 
-int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,
+int integrity_digsig_verify(struct integrity_namespace *ns,
+			    const unsigned int id, const char *sig, int siglen,
 			    const char *digest, int digestlen);
-int integrity_modsig_verify(unsigned int id, const struct modsig *modsig);
-
-int __init integrity_init_keyring(const unsigned int id);
-int __init integrity_load_x509(const unsigned int id, const char *path);
-int __init integrity_load_cert(const unsigned int id, const char *source,
+int integrity_modsig_verify(struct integrity_namespace *ns,
+			    unsigned int id, const struct modsig *modsig);
+
+int __init integrity_init_keyring(struct integrity_namespace *ns,
+				  const unsigned int id);
+int __init integrity_load_x509(struct integrity_namespace *ns,
+			       const unsigned int id, const char *path);
+int __init integrity_load_cert(struct integrity_namespace *ns,
+			       const unsigned int id, const char *source,
 			       const void *data, size_t len, key_perm_t perm);
 #else
 
-static inline int integrity_digsig_verify(const unsigned int id,
+static inline int integrity_digsig_verify(struct integrity_namespace *ns,
+					  const unsigned int id,
 					  const char *sig, int siglen,
 					  const char *digest, int digestlen)
 {
 	return -EOPNOTSUPP;
 }
 
-static inline int integrity_modsig_verify(unsigned int id,
+static inline int integrity_modsig_verify(struct integrity_namespace *ns,
+					  unsigned int id,
 					  const struct modsig *modsig)
 {
 	return -EOPNOTSUPP;
 }
 
-static inline int integrity_init_keyring(const unsigned int id)
+static inline int integrity_init_keyring(struct integrity_namespace *ns,
+					 const unsigned int id)
 {
 	return 0;
 }
 
-static inline int __init integrity_load_cert(const unsigned int id,
+static inline int __init integrity_load_cert(struct integrity_namespace *ns,
+					     const unsigned int id,
 					     const char *source,
 					     const void *data, size_t len,
 					     key_perm_t perm)
diff --git a/security/integrity/integrity_ns.c b/security/integrity/integrity_ns.c
new file mode 100644
index 000000000000..eb09d9567182
--- /dev/null
+++ b/security/integrity/integrity_ns.c
@@ -0,0 +1,40 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2021 IBM Corporation
+ *
+ * Authors:
+ * Stefan Berger <stefanb@us.ibm.com>
+ */
+
+#include <linux/slab.h>
+#include <linux/integrity_namespace.h>
+
+static struct kmem_cache *integrityns_cachep;
+
+struct integrity_namespace init_integrity_ns = {
+	.keyring = {NULL, },
+};
+EXPORT_SYMBOL(init_integrity_ns);
+
+struct integrity_namespace *integrity_create_ns(void)
+{
+	struct integrity_namespace *ns;
+
+	ns = kmem_cache_zalloc(integrityns_cachep, GFP_KERNEL);
+	if (!ns)
+		return ERR_PTR(-ENOMEM);
+
+	return ns;
+}
+
+void integrity_free_ns(struct integrity_namespace *ns)
+{
+	kmem_cache_free(integrityns_cachep, ns);
+}
+
+static int __init integrityns_cache_init(void)
+{
+	integrityns_cachep = KMEM_CACHE(integrity_namespace, SLAB_PANIC);
+	return 0;
+}
+subsys_initcall(integrityns_cache_init)
diff --git a/security/integrity/platform_certs/platform_keyring.c b/security/integrity/platform_certs/platform_keyring.c
index bcafd7387729..faf63eb09fe7 100644
--- a/security/integrity/platform_certs/platform_keyring.c
+++ b/security/integrity/platform_certs/platform_keyring.c
@@ -12,6 +12,7 @@
 #include <linux/cred.h>
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/integrity_namespace.h>
 #include "../integrity.h"
 
 /**
@@ -26,13 +27,14 @@
 void __init add_to_platform_keyring(const char *source, const void *data,
 				    size_t len)
 {
+	struct integrity_namespace *ns = current_integrity_ns();
 	key_perm_t perm;
 	int rc;
 
 	perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW;
 
-	rc = integrity_load_cert(INTEGRITY_KEYRING_PLATFORM, source, data, len,
-				 perm);
+	rc = integrity_load_cert(ns, INTEGRITY_KEYRING_PLATFORM, source,
+				 data, len, perm);
 	if (rc)
 		pr_info("Error adding keys to platform keyring %s\n", source);
 }
@@ -42,9 +44,10 @@ void __init add_to_platform_keyring(const char *source, const void *data,
  */
 static __init int platform_keyring_init(void)
 {
+	struct integrity_namespace *ns = current_integrity_ns();
 	int rc;
 
-	rc = integrity_init_keyring(INTEGRITY_KEYRING_PLATFORM);
+	rc = integrity_init_keyring(ns, INTEGRITY_KEYRING_PLATFORM);
 	if (rc)
 		return rc;
 
-- 
2.31.1

