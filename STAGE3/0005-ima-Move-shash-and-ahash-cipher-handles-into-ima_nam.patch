From bfea48c15387d7ce0e15a2b6f744487d9ef2f53f Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Thu, 2 Dec 2021 17:38:17 -0500
Subject: [PATCH 05/82] ima: Move shash and ahash cipher handles into
 ima_namespace

Move the shash and ahash cipher handles into the ima_namespace so that
IMA namespaces can independently have their own hash contexts.

Limit the emission of the 'ima: Allocated has algorithm: sha256' kernel
log message to the init_ima_ns since otherwise any user creating an IMA
namespace will cause such a message to be emitted.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 security/integrity/ima/ima.h        |  3 ++
 security/integrity/ima/ima_crypto.c | 62 +++++++++++++++--------------
 2 files changed, 35 insertions(+), 30 deletions(-)

diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index f00061f8629c..18f47fa84ba1 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -165,6 +165,9 @@ struct ima_namespace {
 	 * and IMA default algo.
 	 */
 	int ima_extra_slots;
+
+	struct crypto_shash *ima_shash_tfm;
+	struct crypto_ahash *ima_ahash_tfm;
 } __randomize_layout;
 extern struct ima_namespace init_ima_ns;
 
diff --git a/security/integrity/ima/ima_crypto.c b/security/integrity/ima/ima_crypto.c
index c2c930e41480..0dbe75235443 100644
--- a/security/integrity/ima/ima_crypto.c
+++ b/security/integrity/ima/ima_crypto.c
@@ -54,27 +54,25 @@ static const struct kernel_param_ops param_ops_bufsize = {
 module_param_named(ahash_bufsize, ima_bufsize, bufsize, 0644);
 MODULE_PARM_DESC(ahash_bufsize, "Maximum ahash buffer size");
 
-static struct crypto_shash *ima_shash_tfm;
-static struct crypto_ahash *ima_ahash_tfm;
-
 struct ima_algo_desc {
 	struct crypto_shash *tfm;
 	enum hash_algo algo;
 };
 
-static int __init ima_init_ima_crypto(void)
+static int __init ima_init_ima_crypto(struct ima_namespace *ns)
 {
 	long rc;
 
-	ima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);
-	if (IS_ERR(ima_shash_tfm)) {
-		rc = PTR_ERR(ima_shash_tfm);
+	ns->ima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);
+	if (IS_ERR(ns->ima_shash_tfm)) {
+		rc = PTR_ERR(ns->ima_shash_tfm);
 		pr_err("Can not allocate %s (reason: %ld)\n",
 		       hash_algo_name[ima_hash_algo], rc);
 		return rc;
 	}
-	pr_info("Allocated hash algorithm: %s\n",
-		hash_algo_name[ima_hash_algo]);
+	if (ns == &init_ima_ns)
+		pr_info("Allocated hash algorithm: %s\n",
+			hash_algo_name[ima_hash_algo]);
 	return 0;
 }
 
@@ -83,7 +81,7 @@ static struct crypto_shash *ima_alloc_tfm(struct ima_namespace *ns,
 {
 	struct ima_algo_desc *ima_algo_array = ns->ima_algo_array;
 	struct tpm_chip *ima_tpm_chip = ns->ima_tpm_chip;
-	struct crypto_shash *tfm = ima_shash_tfm;
+	struct crypto_shash *tfm = ns->ima_shash_tfm;
 	int rc, i;
 
 	if (algo < 0 || algo >= HASH_ALGO__LAST)
@@ -113,7 +111,7 @@ int __init ima_init_crypto(struct ima_namespace *ns)
 	long rc;
 	int i;
 
-	rc = ima_init_ima_crypto();
+	rc = ima_init_ima_crypto(ns);
 	if (rc)
 		return rc;
 
@@ -155,7 +153,7 @@ int __init ima_init_crypto(struct ima_namespace *ns)
 			continue;
 
 		if (algo == ima_hash_algo) {
-			ima_algo_array[i].tfm = ima_shash_tfm;
+			ima_algo_array[i].tfm = ns->ima_shash_tfm;
 			continue;
 		}
 
@@ -173,7 +171,7 @@ int __init ima_init_crypto(struct ima_namespace *ns)
 
 	if (ns->ima_sha1_idx >= NR_BANKS(ima_tpm_chip)) {
 		if (ima_hash_algo == HASH_ALGO_SHA1) {
-			ima_algo_array[ns->ima_sha1_idx].tfm = ima_shash_tfm;
+			ima_algo_array[ns->ima_sha1_idx].tfm = ns->ima_shash_tfm;
 		} else {
 			ima_algo_array[ns->ima_sha1_idx].tfm =
 						ima_alloc_tfm(ns, HASH_ALGO_SHA1);
@@ -188,7 +186,7 @@ int __init ima_init_crypto(struct ima_namespace *ns)
 
 	if (ns->ima_hash_algo_idx >= NR_BANKS(ima_tpm_chip) &&
 	    ns->ima_hash_algo_idx != ns->ima_sha1_idx) {
-		ima_algo_array[ns->ima_hash_algo_idx].tfm = ima_shash_tfm;
+		ima_algo_array[ns->ima_hash_algo_idx].tfm = ns->ima_shash_tfm;
 		ima_algo_array[ns->ima_hash_algo_idx].algo = ima_hash_algo;
 	}
 
@@ -196,13 +194,13 @@ int __init ima_init_crypto(struct ima_namespace *ns)
 out_array:
 	for (i = 0; i < NR_BANKS(ima_tpm_chip) + ns->ima_extra_slots; i++) {
 		if (!ima_algo_array[i].tfm ||
-		    ima_algo_array[i].tfm == ima_shash_tfm)
+		    ima_algo_array[i].tfm == ns->ima_shash_tfm)
 			continue;
 
 		crypto_free_shash(ima_algo_array[i].tfm);
 	}
 out:
-	crypto_free_shash(ima_shash_tfm);
+	crypto_free_shash(ns->ima_shash_tfm);
 	return rc;
 }
 
@@ -212,7 +210,7 @@ static void ima_free_tfm(struct ima_namespace *ns, struct crypto_shash *tfm)
 	struct tpm_chip *ima_tpm_chip = ns->ima_tpm_chip;
 	int i;
 
-	if (tfm == ima_shash_tfm)
+	if (tfm == ns->ima_shash_tfm)
 		return;
 
 	for (i = 0; i < NR_BANKS(ima_tpm_chip) + ns->ima_extra_slots; i++)
@@ -284,9 +282,10 @@ static void ima_free_pages(void *ptr, size_t size)
 	free_pages((unsigned long)ptr, get_order(size));
 }
 
-static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)
+static struct crypto_ahash *ima_alloc_atfm(struct ima_namespace *ns,
+					   enum hash_algo algo)
 {
-	struct crypto_ahash *tfm = ima_ahash_tfm;
+	struct crypto_ahash *tfm = ns->ima_ahash_tfm;
 	int rc;
 
 	if (algo < 0 || algo >= HASH_ALGO__LAST)
@@ -296,7 +295,7 @@ static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)
 		tfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);
 		if (!IS_ERR(tfm)) {
 			if (algo == ima_hash_algo)
-				ima_ahash_tfm = tfm;
+				ns->ima_ahash_tfm = tfm;
 		} else {
 			rc = PTR_ERR(tfm);
 			pr_err("Can not allocate %s (reason: %d)\n",
@@ -306,9 +305,10 @@ static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)
 	return tfm;
 }
 
-static void ima_free_atfm(struct crypto_ahash *tfm)
+static void ima_free_atfm(struct ima_namespace *ns,
+			  struct crypto_ahash *tfm)
 {
-	if (tfm != ima_ahash_tfm)
+	if (tfm != ns->ima_ahash_tfm)
 		crypto_free_ahash(tfm);
 }
 
@@ -434,18 +434,19 @@ static int ima_calc_file_hash_atfm(struct file *file,
 	return rc;
 }
 
-static int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)
+static int ima_calc_file_ahash(struct ima_namespace *ns,
+			       struct file *file, struct ima_digest_data *hash)
 {
 	struct crypto_ahash *tfm;
 	int rc;
 
-	tfm = ima_alloc_atfm(hash->algo);
+	tfm = ima_alloc_atfm(ns, hash->algo);
 	if (IS_ERR(tfm))
 		return PTR_ERR(tfm);
 
 	rc = ima_calc_file_hash_atfm(file, hash, tfm);
 
-	ima_free_atfm(tfm);
+	ima_free_atfm(ns, tfm);
 
 	return rc;
 }
@@ -564,7 +565,7 @@ int ima_calc_file_hash(struct ima_namespace *ns,
 	i_size = i_size_read(file_inode(f));
 
 	if (ima_ahash_minsize && i_size >= ima_ahash_minsize) {
-		rc = ima_calc_file_ahash(f, hash);
+		rc = ima_calc_file_ahash(ns, f, hash);
 		if (!rc)
 			goto out;
 	}
@@ -704,19 +705,20 @@ static int calc_buffer_ahash_atfm(const void *buf, loff_t len,
 	return rc;
 }
 
-static int calc_buffer_ahash(const void *buf, loff_t len,
+static int calc_buffer_ahash(struct ima_namespace *ns,
+			     const void *buf, loff_t len,
 			     struct ima_digest_data *hash)
 {
 	struct crypto_ahash *tfm;
 	int rc;
 
-	tfm = ima_alloc_atfm(hash->algo);
+	tfm = ima_alloc_atfm(ns, hash->algo);
 	if (IS_ERR(tfm))
 		return PTR_ERR(tfm);
 
 	rc = calc_buffer_ahash_atfm(buf, len, hash, tfm);
 
-	ima_free_atfm(tfm);
+	ima_free_atfm(ns, tfm);
 
 	return rc;
 }
@@ -775,7 +777,7 @@ int ima_calc_buffer_hash(struct ima_namespace *ns,
 	int rc;
 
 	if (ima_ahash_minsize && len >= ima_ahash_minsize) {
-		rc = calc_buffer_ahash(buf, len, hash);
+		rc = calc_buffer_ahash(ns, buf, len, hash);
 		if (!rc)
 			return 0;
 	}
-- 
2.36.1

