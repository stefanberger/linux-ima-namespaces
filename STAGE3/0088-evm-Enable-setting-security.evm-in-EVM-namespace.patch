From 42363caa761300e57d8e2f3a3d0838a87693d08d Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.ibm.com>
Date: Thu, 19 May 2022 14:22:05 -0400
Subject: [PATCH 88/89] evm: Enable setting security.evm in EVM namespace

Modify cap_inode_setxattr() and cap_inode_removexattr() so that the
evaluation of capabilities required to access security.evm is deferred to
ima_inode_setxattr() and ima_inode_removexattr() respectively.

Modify evm_protect_xattr(), which is called by evm_inode_setxattr() and
evm_inode_removexattr(), so that the capabilities are evaluated there.
Add the ns_capable() check previously executed by cap_inode_setxattr() to
this function. Further, for allowing setting the EVM xattr inside an EVM
namespace, also allow to use CAP_MAC_ADMIN so that regular users spawning
an EVM namespace can also sign files in the EVM namespace if those files
have owner and group mappings in the user namespace.
If both CAP_SYS_ADMIN and CAP_MAC_ADMIN are missing in an EVM namespace,
or if the file owner and group cannot be mapped then writing and removing
of security.evm xattr is not possible.

Signed-off-by: Stefan Berger <stefanb@linux.ibm.com>
---
 security/commoncap.c              | 11 +++++++++++
 security/integrity/evm/evm_main.c | 23 +++++++++++++++--------
 2 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/security/commoncap.c b/security/commoncap.c
index 2a61d8a35506..2713166c0287 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -1009,6 +1009,9 @@ int cap_inode_setxattr(struct mnt_idmap *idmap,
 	 * If IMA namespacing is enabled then setting security.ima is allowed
 	 * for users as well and the check for XATTR_NAME_IMA will be done in
 	 * ima_inode_setxattr() once CONIG_IMA_APPRAISE is set.
+	 * Further, setting security.evm is allowed for users and the check
+	 * for XATTR_NAME_EVM will be done in evm_inode_setxattr() if
+	 * CONFIG_EVM is set.
 	 * Also, all 'security.' xattrs in a use namespace will be handled
 	 * by EVM with CAP_MAC_ADMIN if EVM is also enabled.
 	 */
@@ -1018,6 +1021,9 @@ int cap_inode_setxattr(struct mnt_idmap *idmap,
 			return 0;
 
 		if (IS_ENABLED(CONFIG_EVM)) {
+			if (strcmp(name, XATTR_NAME_EVM) == 0)
+				return 0;
+
 			if (current_user_ns() != &init_user_ns &&
 			    mac_admin_ns_capable(current_user_ns()) &&
 			    privileged_wrt_inode_uidgid(current_user_ns(),
@@ -1076,6 +1082,9 @@ int cap_inode_removexattr(struct mnt_idmap *idmap,
 	 * If IMA namespacing is enabled then removing security.ima is allowed
 	 * for users as well and the check for XATTR_NAME_IMA will be done in
 	 * ima_inode_removexattr() once CONIG_IMA_APPRAISE is set.
+	 * Further, setting security.evm is allowed for users and the check
+	 * for XATTR_NAME_EVM will be done in evm_inode_setxattr() if
+	 * CONFIG_EVM is set.
 	 * Also, all 'security.' xattrs in a use namespace will be handled
 	 * by EVM with CAP_MAC_ADMIN if EVM is also enabled.
 	 */
@@ -1085,6 +1094,8 @@ int cap_inode_removexattr(struct mnt_idmap *idmap,
 			return 0;
 
 		if (IS_ENABLED(CONFIG_EVM)) {
+			if (strcmp(name, XATTR_NAME_EVM) == 0)
+				return 0;
 			if (current_user_ns() != &init_user_ns &&
 			    mac_admin_ns_capable(current_user_ns()) &&
 			    privileged_wrt_inode_uidgid(current_user_ns(),
diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c
index 7dbd60a79868..bca80d04b563 100644
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@ -552,10 +552,18 @@ static int evm_protect_xattr(struct evm_namespace *ns,
 			     struct dentry *dentry, const char *xattr_name,
 			     const void *xattr_value, size_t xattr_value_len)
 {
+	struct user_namespace *user_ns = dentry->d_sb->s_user_ns;
+	struct inode *inode = d_backing_inode(dentry);
 	enum integrity_status evm_status;
 
 	if (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {
-		if (!capable(CAP_SYS_ADMIN))
+		if (!ns_capable(user_ns, CAP_SYS_ADMIN) &&
+		    !capable(CAP_SYS_ADMIN))
+			return -EPERM;
+		/* Allow users to set security.evm in user namespace */
+		if (!mac_admin_ns_capable(current_user_ns()) ||
+		    !privileged_wrt_inode_uidgid(current_user_ns(),
+						 idmap, inode))
 			return -EPERM;
 	} else if (!evm_protected_xattr(ns, xattr_name)) {
 		if (!posix_xattr_acl(xattr_name))
@@ -636,13 +644,14 @@ int evm_inode_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,
 		       size_t xattr_value_len)
 {
 	const struct evm_ima_xattr_data *xattr_data = xattr_value;
+	struct inode *inode = d_backing_inode(dentry);
 	struct evm_namespace *ns = current_evm_ns();
 
 	/* Policy permits modification of the protected xattrs even though
 	 * there's no HMAC key loaded
 	 */
-	if (ns == &init_evm_ns &&
-	    (ns->evm_initialized & EVM_ALLOW_METADATA_WRITES))
+	if (ns->evm_initialized & EVM_ALLOW_METADATA_WRITES &&
+	    privileged_wrt_inode_uidgid(current_user_ns(), idmap, inode))
 		return 0;
 
 	if (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {
@@ -651,9 +660,6 @@ int evm_inode_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,
 		if (xattr_data->type != EVM_IMA_XATTR_DIGSIG &&
 		    xattr_data->type != EVM_XATTR_PORTABLE_DIGSIG)
 			return -EPERM;
-
-		if (ns != &init_evm_ns)
-			return -EPERM;
 	}
 	return evm_protect_xattr(ns, idmap, dentry, xattr_name,
 				 xattr_value, xattr_value_len);
@@ -671,12 +677,13 @@ int evm_inode_setxattr(struct mnt_idmap *idmap, struct dentry *dentry,
 int evm_inode_removexattr(struct mnt_idmap *idmap,
 			  struct dentry *dentry, const char *xattr_name)
 {
+	struct inode *inode = d_backing_inode(dentry);
 	struct evm_namespace *ns = current_evm_ns();
 	/* Policy permits modification of the protected xattrs even though
 	 * there's no HMAC key loaded
 	 */
-	if (ns == &init_evm_ns &&
-	    ns->evm_initialized & EVM_ALLOW_METADATA_WRITES)
+	if (ns->evm_initialized & EVM_ALLOW_METADATA_WRITES &&
+	    privileged_wrt_inode_uidgid(current_user_ns(), idmap, inode))
 		return 0;
 
 	return evm_protect_xattr(ns, idmap, dentry, xattr_name, NULL, 0);
-- 
2.40.1

